=Écrire ses tests

==Assertions

===variable

C’est l’assertion de base de toutes les variables. Elle contient les tests nécessaires à n’importe quel type de variable.

====isCallable====variableIsCallable

##isCallable## vérifie que la variable peut être appelée comme fonction.

[[[php
$f = function() {
    // code
};

$this
    ->variable($f)
        ->isCallable()  // passe

    ->variable('\Vendor\Project\foobar')
        ->isCallable()

    ->variable(array('\Vendor\Project\Foo', 'bar'))
        ->isCallable()

    ->variable('\Vendor\Project\Foo::bar')
        ->isCallable()
;
]]]

====isEqualTo====variableIsEqualTo

##isEqualTo## vérifie que la variable est égale à une certaine donnée.

[[[php
$a = 'a';

$this
    ->variable($a)
        ->isEqualTo('a')    // passe
;
]]]

{{{warning
##isEqualTo## ne teste pas le type de la variable. Si vous souhaitez vérifier également son type, utilisez ##[[isIdenticalTo|#variableIsIdenticalTo]]##.
}}}

====isIdenticalTo====variableIsIdenticalTo

##isIdenticalTo## vérifie que la variable a la même valeur et le même type qu’une certaine donnée. Dans le cas d’objets, ##isIdenticalTo## vérifie que les données pointent sur la même instance.

[[[php
$a = '1';

$this
    ->variable($a)
        ->isIdenticalTo(1)          // échoue
;

$stdClass1 = new \StdClass();
$stdClass2 = new \StdClass();
$stdClass3 = $stdClass1;

$this
    ->variable($stdClass1)
        ->isIdenticalTo(stdClass3)  // passe
        ->isIdenticalTo(stdClass2)  // échoue
;
]]]

{{{warning
##isIdenticalTo## teste le type de la variable. Si vous ne souhaitez pas vérifier son type, utilisez ##[[isEqualTo|#variableIsEqualTo]]##.
}}}

====isNotCallable====variableIsNotCallable

##isNotCallable## vérifie que la variable ne peut pas être appelée comme fonction.

[[[php
$f = function() {
    // code
};
$int    = 1;
$string = 'nonExistingMethod';

$this
    ->variable($f)
        ->isNotCallable()   // échoue

    ->variable($int)
        ->isNotCallable()   // passe

    ->variable($string)
        ->isNotCallable()   // passe

    ->variable(new StdClass)
        ->isNotCallable()   // passe
;
]]]

====isNotEqualTo====variableIsNotEqualTo

##isNotEqualTo## vérifie que la variable n’a pas la même valeur qu’une certaine donnée.

[[[php
$a       = 'a';
$aString = '1';

$this
    ->variable($a)
        ->isNotEqualTo('b')     // passe
        ->isNotEqualTo('a')     // échoue

    ->variable($aString)
        ->isNotEqualTo($1)      // échoue
;
]]]

{{{warning
##isNotEqualTo## ne teste pas le type de la variable. Si vous souhaitez vérifier également son type, utilisez ##[[isNotIdenticalTo|#variableIsNotIdenticalTo]]##.
}}}

====isNotIdenticalTo====variableIsNotIdenticalTo

##isNotIdenticalTo## vérifie que la variable n’a ni le même type ni la même valeur qu’une certaine donnée.

Dans le cas d’objets, ##isNotIdenticalTo## vérifie que les données ne pointent pas sur la même instance.

[[[php
$a = '1';

$this
    ->variable($a)
        ->isNotIdenticalTo(1)           // passe
;

$stdClass1 = new \StdClass();
$stdClass2 = new \StdClass();
$stdClass3 = $stdClass1;

$this
    ->variable($stdClass1)
        ->isNotIdenticalTo(stdClass2)   // passe
        ->isNotIdenticalTo(stdClass3)   // échoue
;
]]]

{{{warning
##isNotIdenticalTo## teste le type de la variable. Si vous ne souhaitez pas vérifier son type, utilisez ##[[isNotEqualTo|#variableIsNotEqualTo]]##.
}}}

====isNull

##isNull## vérifie que la variable est nulle.

[[[php
$emptyString = '';
$null        = null;

$this
    ->variable($emptyString)
        ->isNull()              // échoue
                                // (c'est vide mais pas null)

    ->variable($null)
        ->isNull()              // passe
;
]]]

====isNotNull

##isNotNull## vérifie que la variable n’est pas nulle.

[[[php
$emptyString = '';
$null        = null;

$this
    ->variable($emptyString)
        ->isNotNull()           // passe (c'est vide mais pas null)

    ->variable($null)
        ->isNotNull()           // échoue
;
]]]



===boolean

C’est l’assertion dédiée aux booléens.

Si vous essayez de tester une variable qui n’est pas un booléen avec cette assertion, cela échouera.

{{{info
##null## n’est pas un booléen. Reportez-vous au manuel de PHP pour savoir ce que ##[[is_bool|http://php.net/is_bool]]## considère ou non comme un booléen.
}}}

====isEqualTo====booleanIsEqualTo

{{{inheritance
##isEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isEqualTo##|#variableIsEqualTo]]
}}}

====isFalse

##isFalse## vérifie que le booléen est strictement égal à ##false##.

[[[php
$true  = true;
$false = false;

$this
    ->boolean($true)
        ->isFalse()     // échoue

    ->boolean($false)
        ->isFalse()     // passe
;
]]]

====isIdenticalTo====booleanIsIdenticalTo

{{{inheritance
##isIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isIdenticalTo##|#variableIsIdenticalTo]]
}}}

====isNotEqualTo====booleanIsNotEqualTo

{{{inheritance
##isNotEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotEqualTo##|#variableIsNotEqualTo]]
}}}

====isNotIdenticalTo====booleanIsNotIdenticalTo

{{{inheritance
##isNotIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotIdenticalTo##|#variableIsNotIdenticalTo]]
}}}

====isTrue

##isTrue## vérifie que le booléen est strictement égal à ##true##.

[[[php
$true  = true;
$false = false;

$this
    ->boolean($true)
        ->isTrue()      // passe

    ->boolean($false)
        ->isTrue()      // échoue
;
]]]



===integer

C’est l’assertion dédiée aux entiers.

Si vous essayez de tester une variable qui n’est pas un entier avec cette assertion, cela échouera.

{{{info
##null## n’est pas un entier. Reportez-vous au manuel de PHP pour savoir ce que ##[[is_int|http://php.net/is_int]]## considère ou non comme un entier.
}}}

====isEqualTo====integerIsEqualTo

{{{inheritance
##isEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isEqualTo##|#variableIsEqualTo]]
}}}

====isGreaterThan====integerIsGreaterThan

##isGreaterThan## vérifie que l’entier est strictement supérieur à une certaine donnée.

[[[php
$zero = 0;

$this
    ->integer($zero)
        ->isGreaterThan(-1)     // passe
        ->isGreaterThan('-1')   // échoue car "-1"
                                // n'est pas un entier
        ->isGreaterThan(0)      // échoue
;
]]]

====isGreaterThanOrEqualTo====integerIsGreaterThanOrEqualTo

##isGreaterThanOrEqualTo## vérifie que l’entier est supérieur ou égal à une certaine donnée.

[[[php
$zero = 0;

$this
    ->integer($zero)
        ->isGreaterThanOrEqualTo(-1)    // passe
        ->isGreaterThanOrEqualTo(0)     // passe
        ->isGreaterThanOrEqualTo('-1')  // échoue car "-1"
                                        // n'est pas un entier
;
]]]

====isIdenticalTo====integerIsIdenticalTo

{{{inheritance
##isIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isIdenticalTo##|#variableIsIdenticalTo]]
}}}

====isLessThan====integerIsLessThan

##isLessThan## vérifie que l’entier est strictement inférieur à une certaine donnée.

[[[php
$zero = 0;

$this
    ->integer($zero)
        ->isLessThan(10)    // passe
        ->isLessThan('10')  // échoue car "10" n'est pas un entier
        ->isLessThan(0)     // échoue
;
]]]

====isLessThanOrEqualTo====integerIsLessThanOrEqualTo

##isLessThanOrEqualTo## vérifie que l’entier est inférieur ou égal à une certaine donnée.

[[[php
$zero = 0;

$this
    ->integer($zero)
        ->isLessThanOrEqualTo(10)       // passe
        ->isLessThanOrEqualTo(0)        // passe
        ->isLessThanOrEqualTo('10')     // échoue car "10"
                                        // n'est pas un entier
;
]]]

====isNotEqualTo====integerIsNotEqualTo

{{{inheritance
##isNotEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotEqualTo##|#variableIsNotEqualTo]]
}}}

====isNotIdenticalTo====integerIsNotIdenticalTo

{{{inheritance
##isNotIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotIdenticalTo##|#variableIsNotIdenticalTo]]
}}}

====isZero====integerIsZero

##isZero## vérifie que l’entier est égal à 0.

[[[php
$zero    = 0;
$notZero = -1;

$this
    ->integer($zero)
        ->isZero()          // passe

    ->integer($notZero)
        ->isZero()          // échoue
;
]]]

{{{info
##isZero## est équivalent à ##isEqualTo(0)##.
}}}



===float

C’est l’assertion dédiée aux nombres décimaux.

Si vous essayez de tester une variable qui n’est pas un nombre décimal avec cette assertion, cela échouera.

{{{info
##null## n’est pas un nombre décimal. Reportez-vous au manuel de PHP pour savoir ce que ##[[is_float|http://php.net/is_float]]## considère ou non comme un nombre décimal.
}}}

====isEqualTo====floatIsEqualTo

{{{inheritance
##isEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isEqualTo##|#variableIsEqualTo]]
}}}

====isGreaterThan====floatIsGreaterThan

{{{inheritance
##isGreaterThan## est une méthode héritée de l’asserter ##integer##.
Pour plus d’informations, reportez-vous à la documentation de [[##integer::isGreaterThan##|#integerIsGreaterThan]]
}}}

====isGreaterThanOrEqualTo====floatIsGreaterThanOrEqualTo

{{{inheritance
##isGreaterThanOrEqualTo## est une méthode héritée de l’asserter ##integer##.
Pour plus d’informations, reportez-vous à la documentation de [[##integer::isGreaterThanOrEqualTo##|#integerIsGreaterThanOrEqualTo]]
}}}

====isIdenticalTo====floatIsIdenticalTo

{{{inheritance
##isIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isIdenticalTo##|#variableIsIdenticalTo]]
}}}

====isLessThan====floatIsLessThan

{{{inheritance
##isLessThan## est une méthode héritée de l’asserter ##integer##.
Pour plus d’informations, reportez-vous à la documentation de [[##integer::isLessThan##|#integerIsLessThan]]
}}}

====isLessThanOrEqualTo====floatIsLessThanOrEqualTo

{{{inheritance
##isLessThanOrEqualTo## est une méthode héritée de l’asserter ##integer##.
Pour plus d’informations, reportez-vous à la documentation de [[##integer::isLessThanOrEqualoo##|#integerIsLessThanOrEqualTo]]
}}}

====isNearlyEqualTo

##isNearlyEqualTo## vérifie que le nombre décimal est approximativement égal à la valeur qu’elle reçoit en argument.

En effet, en informatique, les nombres décimaux sont gérées d’une façon qui ne permet pas d’effectuer des comparaisons précises sans recourir à des outils spécialisés. Essayez par exemple d’exécuter la commande suivante:

[[[shell
$ php -r 'var_dump(1 - 0.97 === 0.03);'
bool(false)
]]]

Le résultat devrait pourtant être ##true##.

{{{info
Pour avoir plus d’informations sur ce phénomène, reportez-vous au [[manuel de PHP|http://php.net/types.float]].
}}}

Cette méthode cherche donc à minorer ce problème.

[[[php
$float = 1 - 0.97;

$this
    ->float($float)
        ->isNearlyEqualTo(0.03) // passe
        ->isEqualTo(0.03)       // échoue
;
]]]

{{{info
Pour avoir plus d’informations sur l’algorithme utilisé, consultez le [[floating point guide|http://www.floating-point-gui.de/errors/comparison/]].
}}}

====isNotEqualTo====floatIsNotEqualTo

{{{inheritance
##isNotEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotEqualTo##|#variableIsNotEqualTo]]
}}}

====isNotIdenticalTo====floatIsNotIdenticalTo

{{{inheritance
##isNotIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotIdenticalTo##|#variableIsNotIdenticalTo]]
}}}

====isZero====floatIsZero

{{{inheritance
##isZero## est une méthode héritée de l’asserter ##integer##.
Pour plus d’informations, reportez-vous à la documentation de [[##integer::isZero##|#integerIsZero]]
}}}



===sizeOf

C’est l’assertion dédiée aux tests sur la taille des tableaux et des objets implémentant l’interface ##Countable##.

[[[php
$array           = array(1, 2, 3);
$countableObject = new GlobIterator('*');

$this
    ->sizeOf($array)
        ->isEqualTo(3)

    ->sizeOf($countableObject)
        ->isGreaterThan(0)
;
]]]

====isEqualTo====sizeOfIsEqualTo

{{{inheritance
##isEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isEqualTo##|#variableIsEqualTo]]
}}}

====isGreaterThan====sizeOfIsGreaterThan

{{{inheritance
##isGreaterThan## est une méthode héritée de l’asserter ##integer##.
Pour plus d’informations, reportez-vous à la documentation de [[##integer::isGreaterThan##|#integerIsGreaterThan]]
}}}

====isGreaterThanOrEqualTo====sizeOfIsGreaterThanOrEqualTo

{{{inheritance
##isGreaterThanOrEqualTo## est une méthode héritée de l’asserter ##integer##.
Pour plus d’informations, reportez-vous à la documentation de [[##integer::isGreaterThanOrEqualTo##|#integerIsGreaterThanOrEqualTo]]
}}}

====isIdenticalTo====sizeOfIsIdenticalTo

{{{inheritance
##isIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isIdenticalTo##|#variableIsIdenticalTo]]
}}}

====isLessThan====sizeOfIsLessThan

{{{inheritance
##isLessThan## est une méthode héritée de l’asserter ##integer##.
Pour plus d’informations, reportez-vous à la documentation de [[##integer::isLessThan##|#integerIsLessThan]]
}}}

====isLessThanOrEqualTo====sizeOfIsLessThanOrEqualTo

{{{inheritance
##isLessThanOrEqualTo## est une méthode héritée de l’asserter ##integer##.
Pour plus d’informations, reportez-vous à la documentation de [[##integer::isLessThanOrEqualoo##|#integerIsLessThanOrEqualTo]]
}}}

====isNotEqualTo====sizeOfIsNotEqualTo

{{{inheritance
##isNotEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotEqualTo##|#variableIsNotEqualTo]]
}}}

====isNotIdenticalTo====sizeOfIsNotIdenticalTo

{{{inheritance
##isNotIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotIdenticalTo##|#variableIsNotIdenticalTo]]
}}}

====isZero====sizeOfIsZero

{{{inheritance
##isZero## est une méthode héritée de l’asserter ##integer##.
Pour plus d’informations, reportez-vous à la documentation de [[##integer::isZero##|#integerIsZero]]
}}}



===object

C’est l’assertion dédiée aux objets.

Si vous essayez de tester une variable qui n’est pas un objet avec cette assertion, cela échouera.

{{{info
##null## n’est pas un objet. Reportez-vous au manuel de PHP pour savoir ce que ##[[is_object|http://php.net/is_object]]## considère ou non comme un objet.
}}}

====hasSize====objectHasSize

##hasSize## vérifie la taille d’un objet qui implémente l’interface ##Countable##.

[[[php
$countableObject = new GlobIterator('*');

$this
    ->object($countableObject)
        ->hasSize(3)
;
]]]

====isCallable====objectIsCallable

[[[php
class foo
{
    public function __invoke()
    {
        // code
    }
}

$this
    ->object(new foo)
        ->isCallable()  // passe

    ->object(new StdClass)
        ->isCallable()  // échoue
;
]]]

{{{info
Pour être identifiés comme ##callable##, vos objets devront être instanciés à partir de classes qui implémentent la méthode magique [[##\__invoke## | http://www.php.net/manual/fr/language.oop5.magic.php#object.invoke]].
}}}

{{{inheritance
##isCallable## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isCallable##|#variableIsCallable]]
}}}

====isCloneOf====objectIsCloneOf

##isCloneOf## vérifie qu’un objet est le clone d’un objet donné, c’est-à-dire que les objets sont égaux, mais ne pointent pas vers la même instance.

[[[php
$object1 = new \StdClass;
$object2 = new \StdClass;
$object3 = clone($object1);
$object4 = new \StdClass;
$object4->foo = 'bar';

$this
    ->object($object1)
        ->isCloneOf($object2)   // passe
        ->isCloneOf($object3)   // passe
        ->isCloneOf($object4)   // échoue
;
]]]

{{{info
Pour avoir plus de précision sur la comparaison d’objet, reportez-vous au [[manuel de PHP|http://php.net/language.oop5.object-comparison]].
}}}

====isEmpty====objectIsEmpty

##isEmpty## vérifie que la taille d’un objet implémentant l’interface ##Countable## est égale à 0.

[[[php
$countableObject = new GlobIterator('atoum.php');

$this
    ->object($countableObject)
        ->isEmpty()
;
]]]

{{{info
##isEmpty## est équivalent à ##hasSize(0)##.
}}}

====isEqualTo====objectIsEqualTo

##isEqualTo## vérifie qu’un objet est égal à un autre.
Deux objets sont considérés égaux lorsqu’ils ont les mêmes attributs et valeurs, et qu’ils sont des instances de la même classe.

{{{info
Pour avoir plus de précision sur la comparaison d’objet, reportez-vous au [[manuel de PHP|http://php.net/language.oop5.object-comparison]].
}}}

{{{inheritance
##isEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isEqualTo##|#variableIsEqualTo]]
}}}

====isIdenticalTo====objectIsIdenticalTo

##isIdenticalTo## vérifie que deux objets sont identiques.
Deux objets sont considérés identiques lorsqu’ils font référence à la même instance de la même classe.

{{{info
Pour avoir plus de précision sur la comparaison d’objet, reportez-vous au [[manuel de PHP|http://php.net/language.oop5.object-comparison]].
}}}

{{{inheritance
##isIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isIdenticalTo##|#variableIsIdenticalTo]]
}}}

====isInstanceOf====objectIsInstanceOf

##isInstanceOf## vérifie qu’un objet est :
* une instance de la classe donnée,
* une sous-classe de la classe donnée (abstraite ou non),
* une instance d’une classe qui implémente l’interface donnée.

[[[php
$object = new \StdClass();

$this
    ->object($object)
        ->isInstanceOf('\StdClass')     // passe
        ->isInstanceOf('\Iterator')     // échoue
;


interface FooInterface
{
    public function foo();
}

class FooClass implements FooInterface
{
    public function foo()
    {
        echo "foo";
    }
}

class BarClass extends FooClass
{
}

$foo = new FooClass;
$bar = new BarClass;

$this
    ->object($foo)
        ->isInstanceOf('\FooClass')     // passe
        ->isInstanceOf('\FooInterface') // passe
        ->isInstanceOf('\BarClass')     // échoue
        ->isInstanceOf('\StdClass')     // échoue

    ->object($bar)
        ->isInstanceOf('\FooClass')     // passe
        ->isInstanceOf('\FooInterface') // passe
        ->isInstanceOf('\BarClass')     // passe
        ->isInstanceOf('\StdClass')     // échoue
;
]]]

{{{info
Les noms des classes et des interfaces doivent être absolus, car les éventuelles importations d’espace de nommage ne sont pas prises en compte.
}}}

====isNotCallable====objectIsNotCallable

[[[php
class foo
{
    public function __invoke()
    {
        // code
    }
}

$this
    ->variable(new foo)
        ->isNotCallable()   // échoue

    ->variable(new StdClass)
        ->isNotCallable()   // passe
;
]]]

{{{inheritance
##isNotCallable## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotCallable##|#variableIsNotCallable]]
}}}

====isNotEqualTo====objectIsNotEqualTo

##isEqualTo## vérifie qu’un objet n’est pas égal à un autre.
Deux objets sont considérés égaux lorsqu’ils ont les mêmes attributs et valeurs, et qu’ils sont des instances de la même classe.

{{{info
Pour avoir plus de précision sur la comparaison d’objet, reportez-vous au [[manuel de PHP|http://php.net/language.oop5.object-comparison]].
}}}

{{{inheritance
##isNotEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotEqualTo##|#variableIsNotEqualTo]]
}}}

====isNotIdenticalTo====objectIsNotIdenticalTo

##isIdenticalTo## vérifie que deux objets ne sont pas identiques.
Deux objets sont considérés identiques lorsqu’ils font référence à la même instance de la même classe.

{{{info
Pour avoir plus de précision sur la comparaison d’objet, reportez-vous au [[manuel de PHP|http://php.net/language.oop5.object-comparison]].
}}}

{{{inheritance
##isNotIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotIdenticalTo##|#variableIsNotIdenticalTo]]
}}}

===dateInterval

C’est l’assertion dédiée à l’objet ##[[DateInterval|http://php.net/dateinterval]]##.

Si vous essayez de tester une variable qui n’est pas un objet ##DateInterval## (ou une classe qui l’étend) avec cette assertion, cela échouera.

====isCloneOf====dateIntervalIsCloneOf

{{{inheritance
##isCloneOf## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isCloneOf##|#objectIsCloneOf]]
}}}

====isEqualTo====dateIntervalIsEqualTo

##isEqualTo## vérifie que la durée de l’objet ##DateInterval## est égale à la durée d’un autre objet ##DateInterval##.

[[[php
$di = new DateInterval('P1D');

$this
    ->dateInterval($di)
        ->isEqualTo(                // passe
            new DateInterval('P1D')
        )
        ->isEqualTo(                // échoue
            new DateInterval('P2D')
        )
;
]]]

====isGreaterThan====dateIntervalIsGreaterThan

##isGreaterThan## vérifie que la durée de l’objet ##DateInterval## est supérieure à la durée d’un autre objet ##DateInterval##.

[[[php
$di = new DateInterval('P2D');

$this
    ->dateInterval($di)
        ->isGreaterThan(            // passe
            new DateInterval('P1D')
        )
        ->isGreaterThan(            // échoue
            new DateInterval('P2D')
        )
;
]]]

====isGreaterThanOrEqualTo====dateIntervalIsGreaterThanOrEqualTo

##isGreaterThanOrEqualTo## vérifie que la durée de l’objet ##DateInterval## est supérieure ou égale à la durée d’un autre objet ##DateInterval##.

[[[php
$di = new DateInterval('P2D');

$this
    ->dateInterval($di)
        ->isGreaterThanOrEqualTo(   // passe
            new DateInterval('P1D')
        )
        ->isGreaterThanOrEqualTo(   // passe
            new DateInterval('P2D')
        )
        ->isGreaterThanOrEqualTo(   // échoue
            new DateInterval('P3D')
        )
;
]]]

====isIdenticalTo====dateIntervalIsIdenticalTo

{{{inheritance
##isIdenticalTo## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isIdenticalTo##|#objectIsIdenticalTo]]
}}}

====isInstanceOf====dateIntervalIsInstanceOf

{{{inheritance
##isInstanceOf## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isInstanceOf##|#objectIsInstanceOf]]
}}}

====isLessThan====dateIntervalIsLessThan

##isLessThan## vérifie que la durée de l’objet ##DateInterval## est inférieure à la durée d’un autre objet ##DateInterval##.

[[[php
$di = new DateInterval('P1D');

$this
    ->dateInterval($di)
        ->isLessThan(               // passe
            new DateInterval('P2D')
        )
        ->isLessThan(               // échoue
            new DateInterval('P1D')
        )
;
]]]

====isLessThanOrEqualTo====dateIntervalIsLessThanOrEqualTo

##isLessThanOrEqualTo## vérifie que la durée de l’objet ##DateInterval## est inférieure ou égale à la durée d’un autre objet ##DateInterval##.

[[[php
$di = new DateInterval('P2D');

$this
    ->dateInterval($di)
        ->isLessThanOrEqualTo(      // passe
            new DateInterval('P3D')
        )
        ->isLessThanOrEqualTo(      // passe
            new DateInterval('P2D')
        )
        ->isLessThanOrEqualTo(      // échoue
            new DateInterval('P1D')
        )
;
]]]

====isNotEqualTo====dateIntervalIsNotEqualTo

{{{inheritance
##isNotEqualTo## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isNotEqualTo##|#objectIsNotEqualTo]]
}}}

====isNotIdenticalTo====dateIntervalIsNotIdenticalTo

{{{inheritance
##isNotIdenticalTo## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isNotIdenticalTo##|#objectIsNotIdenticalTo]]
}}}

====isZero====dateIntervalIsZero

##isZero## vérifie que la durée de l’objet ##DateInterval## est égale à 0.

[[[php
$di1 = new DateInterval('P0D');
$di2 = new DateInterval('P1D');

$this
    ->dateInterval($di1)
        ->isZero()      // passe
    ->dateInterval($di2)
        ->isZero()      // échoue
;
]]]


===dateTime

C’est l’assertion dédiée à l’objet ##[[DateTime|http://php.net/datetime]]##.

Si vous essayez de tester une variable qui n’est pas un objet ##DateTime## (ou une classe qui l’étend) avec cette assertion, cela échouera.

====hasDate====dateTimeHasDate

##hasDate## vérifie la partie date de l’objet ##DateTime##.

[[[php
$dt = new DateTime('1981-02-13');

$this
    ->dateTime($dt)
        ->hasDate('1981', '02', '13')   // passe
        ->hasDate('1981', '2',  '13')   // passe
        ->hasDate(1981,   2,    13)     // passe
;
]]]

====hasDateAndTime====dateTimeHasDateAndTime

##hasDateAndTime## vérifie la date et l’horaire de l’objet ##DateTime##

[[[php
$dt = new DateTime('1981-02-13 01:02:03');

$this
    ->dateTime($dt)
        // passe
        ->hasDateAndTime('1981', '02', '13', '01', '02', '03')
        // passe
        ->hasDateAndTime('1981', '2',  '13', '1',  '2',  '3')
        // passe
        ->hasDateAndTime(1981,   2,    13,   1,    2,    3)
;
]]]

====hasDay====dateTimeHasDay

##hasDay## vérifie le jour de l’objet ##DateTime##.

[[[php
$dt = new DateTime('1981-02-13');

$this
    ->dateTime($dt)
        ->hasDay(13)        // passe
;
]]]

====hasHours====dateTimeHasHours

##hasHours## vérifie les heures de l’objet ##DateTime##.

[[[php
$dt = new DateTime('01:02:03');

$this
    ->dateTime($dt)
        ->hasHours('01')    // passe
        ->hasHours('1')     // passe
        ->hasHours(1)       // passe
;
]]]

====hasMinutes====dateTimeHasMinutes

##hasMinutes## vérifie les minutes de l’objet ##DateTime##.

[[[php
$dt = new DateTime('01:02:03');

$this
    ->dateTime($dt)
        ->hasMinutes('02')  // passe
        ->hasMinutes('2')   // passe
        ->hasMinutes(2)     // passe
;
]]]

====hasMonth====dateTimeHasMonth

##hasMonth## vérifie le mois de l’objet ##DateTime##.

[[[php
$dt = new DateTime('1981-02-13');

$this
    ->dateTime($dt)
        ->hasMonth(2)       // passe
;
]]]

====hasSeconds====dateTimeHasSeconds

##hasSeconds## vérifie les secondes de l’objet ##DateTime##.

[[[php
$dt = new DateTime('01:02:03');

$this
    ->dateTime($dt)
        ->hasSeconds('03')    // passe
        ->hasSeconds('3')     // passe
        ->hasSeconds(3)       // passe
;
]]]

====hasTime====dateTimeHasTime

##hasTime## vérifie la partie horaire de l’objet ##DateTime##

[[[php
$dt = new DateTime('01:02:03');

$this
    ->dateTime($dt)
        ->hasTime('01', '02', '03')     // passe
        ->hasTime('1',  '2',  '3')      // passe
        ->hasTime(1,    2,    3)        // passe
;
]]]

====hasTimezone====dateTimeHasTimezone

##hasTimezone## vérifie le fuseau horaire de l’objet ##DateTime##.

[[[php
$dt = new DateTime();

$this
    ->dateTime($dt)
        ->hasTimezone('Europe/Paris')
;
]]]

====hasYear====dateTimeHasYear

##hasYear## vérifie l’année de l’objet ##DateTime##.

[[[php
$dt = new DateTime('1981-02-13');

$this
    ->dateTime($dt)
        ->hasYear(1981)     // passe
;
]]]

====isCloneOf====dateTimeIsCloneOf

{{{inheritance
##isCloneOf## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isCloneOf##|#objectIsCloneOf]]
}}}

====isEqualTo====dateTimeIsEqualTo

{{{inheritance
##isEqualTo## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isEqualTo##|#objectIsEqualTo]]
}}}

====isIdenticalTo====datTimeIsIdenticalTo

{{{inheritance
##isIdenticalTo## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isIdenticalTo##|#objectIsIdenticalTo]]
}}}

====isInstanceOf====dateTimeIsInstanceOf

{{{inheritance
##isInstanceOf## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isInstanceOf##|#objectIsInstanceOf]]
}}}

====isNotEqualTo====dateTimeIsNotEqualTo

{{{inheritance
##isNotEqualTo## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isNotEqualTo##|#objectIsNotEqualTo]]
}}}

====isNotIdenticalTo====dateTimeIsNotIdenticalTo

{{{inheritance
##isNotIdenticalTo## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isNotIdenticalTo##|#objectIsNotIdenticalTo]]
}}}



===mysqlDateTime

C’est l’assertion dédiée aux objets décrivant une date MySQL et basée sur l’objet ##[[DateTime|http://php.net/datetime]]##.

Les dates doivent utiliser un format compatible avec MySQL et de nombreux autre ??SGBD|Système de gestion de base de données??), à savoir « Y-m-d H:i:s » (reportez-vous à la documentation de la fonction ##[[date()|http://php.net/date]]## du manuel de PHP pour plus d’information).

Si vous essayez de tester une variable qui n’est pas un objet ##DateTime## (ou une classe qui l’étend) avec cette assertion, cela échouera.

====hasDate====mysqlDateTimeHasDate

{{{inheritance
##hasDate## est une méthode héritée de l’asserter ##dateTime##.
Pour plus d’informations, reportez-vous à la documentation de [[##dateTime::hasDate##|#dateTimeHasDate]]
}}}

====hasDateAndTime====mysqlDateTimeHasDateAndTime

{{{inheritance
##hasDateAndTime## est une méthode héritée de l’asserter ##dateTime##.
Pour plus d’informations, reportez-vous à la documentation de [[##dateTime::hasDateAndTime##|#dateTimeHasDateAndTime]]
}}}

====hasDay====mysqlDateTimeHasDay

{{{inheritance
##hasDay## est une méthode héritée de l’asserter ##dateTime##.
Pour plus d’informations, reportez-vous à la documentation de [[##dateTime::hasDay##|#dateTimeHasDay]]
}}}

====hasHours====mysqlDateTimeHasHours

{{{inheritance
##hasHours## est une méthode héritée de l’asserter ##dateTime##.
Pour plus d’informations, reportez-vous à la documentation de [[##dateTime::hasHours##|#dateTimeHasHours]]
}}}

====hasMinutes====mysqlDateTimeHasMinutes

{{{inheritance
##hasMinutes## est une méthode héritée de l’asserter ##dateTime##.
Pour plus d’informations, reportez-vous à la documentation de [[##dateTime::hasMinutes##|#dateTimeHasMinutes]]
}}}

====hasMonth====mysqlDateTimeHasMonth

{{{inheritance
##hasMonth## est une méthode héritée de l’asserter ##dateTime##.
Pour plus d’informations, reportez-vous à la documentation de [[##dateTime::hasMonth##|#dateTimeHasMonth]]
}}}

====hasSeconds====mysqlDateTimeHasSeconds

{{{inheritance
##hasSeconds## est une méthode héritée de l’asserter ##dateTime##.
Pour plus d’informations, reportez-vous à la documentation de [[##dateTime::hasSeconds##|#dateTimeHasSeconds]]
}}}

====hasTime====mysqlDateTimeHasTime

{{{inheritance
##hasTime## est une méthode héritée de l’asserter ##dateTime##.
Pour plus d’informations, reportez-vous à la documentation de [[##dateTime::hasTime##|#dateTimeHasTime]]
}}}

====hasTimezone====mysqlDateTimeHasTimezone

{{{inheritance
##hasTimezone## est une méthode héritée de l’asserter ##dateTime##.
Pour plus d’informations, reportez-vous à la documentation de [[##dateTime::hasTimezone##|#dateTimeHasTimezone]]
}}}

====hasYear====mysqlDateTimeHasYear

{{{inheritance
##hasYear## est une méthode héritée de l’asserter ##dateTime##.
Pour plus d’informations, reportez-vous à la documentation de [[##dateTime::hasYear##|#dateTimeHasTimezone]]
}}}

====isCloneOf====mysqlDateTimeIsCloneOf

{{{inheritance
##isCloneOf## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isCloneOf##|#objectIsCloneOf]]
}}}

====isEqualTo====mysqlDateTimeIsEqualTo

{{{inheritance
##isEqualTo## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isEqualTo##|#objectIsEqualTo]]
}}}

====isIdenticalTo====mysqlDateTimeIsIdenticalTo

{{{inheritance
##isIdenticalTo## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isIdenticalTo##|#objectIsIdenticalTo]]
}}}

====isInstanceOf====mysqlDateTimeIsInstanceOf

{{{inheritance
##isInstanceOf## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isInstanceOf##|#objectIsInstanceOf]]
}}}

====isNotEqualTo====mysqlDateTimeIsNotEqualTo

{{{inheritance
##isNotEqualTo## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isNotEqualTo##|#objectIsNotEqualTo]]
}}}

====isNotIdenticalTo====mysqlDateTimeIsNotIdenticalTo

{{{inheritance
##isNotIdenticalTo## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isNotIdenticalTo##|#objectIsNotIdenticalTo]]
}}}



===exception

C’est l’assertion dédiée aux exceptions.

[[[php
$this
    ->exception(
        function() use($myObject) {
            // ce code lève une exception: throw new \Exception;
            $myObject->doOneThing('wrongParameter');
        }
    )
;
]]]

{{{info
La syntaxe utilise les fonctions anonymes (aussi appelées fermetures ou closures) introduites en PHP 5.3. Reportez-vous au [[manuel de PHP|http://php.net/functions.anonymous]] pour avoir plus d’informations sur le sujet.
}}}

====hasCode

##hasCode## vérifie le code de l’exception.

[[[php
$this
    ->exception(
        function() use($myObject) {
            // ce code lève une exception: throw new \Exception('Message', 42);
            $myObject->doOneThing('wrongParameter');
        }
    )
        ->hasCode(42)
;
]]]

====hasDefaultCode

##hasDefaultCode## vérifie que le code de l’exception est la valeur par défaut, c’est-à-dire 0.

[[[php
$this
    ->exception(
        function() use($myObject) {
            // ce code lève une exception: throw new \Exception;
            $myObject->doOneThing('wrongParameter');
        }
    )
        ->hasDefaultCode()
;
]]]

{{{info
##hasDefaultCode## est équivalent à ##hasCode(0)##.
}}}

====hasMessage

##hasMessage## vérifie le message de l’exception.

[[[php
$this
    ->exception(
        function() use($myObject) {
            // ce code lève une exception: throw new \Exception('Message');
            $myObject->doOneThing('wrongParameter');
        }
    )
        ->hasMessage('Message')     // passe
        ->hasMessage('message')     // échoue
;
]]]

====hasNestedException

##hasNestedException## vérifie que l’exception contient une référence vers l’exception précédente. Si l’exception est précisée, cela va également vérifier la classe de l’exception.

[[[php
$this
    ->exception(
        function() use($myObject) {
            // ce code lève une exception: throw new \Exception('Message');
            $myObject->doOneThing('wrongParameter');
        }
    )
        ->hasNestedException()      // échoue

    ->exception(
        function() use($myObject) {
            try {
                // ce code lève une exception: throw new \FirstException('Message 1', 42);
                $myObject->doOneThing('wrongParameter');
            }
            // ... l'exception est attrapée...
            catch(\FirstException $e) {
                // ... puis relancée, encapsulée dans une seconde exception
                throw new \SecondException('Message 2', 24, $e);
            }
        }
    )
        ->isInstanceOf('\FirstException')           // échoue
        ->isInstanceOf('\SecondException')          // passe

        ->hasNestedException()                      // passe
        ->hasNestedException(new \FirstException)   // passe
        ->hasNestedException(new \SecondException)  // échoue
;
]]]

====isCloneOf====exceptionIsCloneOf

{{{inheritance
##isCloneOf## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isCloneOf##|#objectIsCloneOf]]
}}}

====isEqualTo====exceptionIsEqualTo

{{{inheritance
##isEqualTo## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isEqualTo##|#objectIsEqualTo]]
}}}

====isIdenticalTo====exceptionIsIdenticalTo

{{{inheritance
##isIdenticalTo## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isIdenticalTo##|#objectIsIdenticalTo]]
}}}

====isInstanceOf====exceptionIsInstanceOf

{{{inheritance
##isInstanceOf## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isInstanceOf##|#objectIsInstanceOf]]
}}}

====isNotEqualTo====exceptionIsNotEqualTo

{{{inheritance
##isNotEqualTo## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isNotEqualTo##|#objectIsNotEqualTo]]
}}}

====isNotIdenticalTo====exceptionIsNotIdenticalTo

{{{inheritance
##isNotIdenticalTo## est une méthode héritée de l’asserter ##object##.
Pour plus d’informations, reportez-vous à la documentation de [[##object::isNotIdenticalTo##|#objectIsNotIdenticalTo]]
}}}

====message

##message## vous permet de récupérer un asserter de type ##[[string|#string]]## contenant le message de l'exception testée.

[[[php
$this
    ->exception(
        function() {
            throw new \Exception('My custom message to test');
        }
    )
        ->message
            ->contains('message')
;
]]]



===array

C’est l’assertion dédiée aux tableaux.

{{{info
##array## étant un mot réservé en PHP, il n’a pas été possible de créer une assertion ##array##. Elle s’appelle donc ##phpArray## et un alias ##array## a été créé. Vous pourrez donc rencontrer des ##->phpArray()## ou des ##->array()##.
}}}

Il est conseillé d’utiliser exclusivement ##->array()## afin de simplifier la lecture des tests.

====contains====arrayContains

##contains## vérifie qu’un tableau contient une certaine donnée.

[[[php
$fibonacci = array('1', 2, '3', 5, '8', 13, '21');

$this
    ->array($fibonacci)
        ->contains('1')     // passe
        ->contains(1)       // passe, ne vérifie pas...
        ->contains('2')     // ... le type de la donnée
        ->contains(10)      // échoue
;
]]]

{{{info
##contains## ne fait pas de recherche récursive.
}}}

{{{warning
##contains## ne teste pas le type de la donnée. Si vous souhaitez vérifier également son type, utilisez ##[[strictlyContains|#strictlyContains]]##.
}}}

====containsValues

##containsValues## vérifie qu’un tableau contient toutes les données fournies dans un tableau.

[[[php
$fibonacci = array('1', 2, '3', 5, '8', 13, '21');

$this
    ->array($array)
        ->containsValues(array(1, 2, 3))        // passe
        ->containsValues(array('5', '8', '13')) // passe
        ->containsValues(array(0, 1, 2))        // échoue
;
]]]

{{{info
##containsValues## ne fait pas de recherche récursive.
}}}

{{{warning
##containsValues## ne teste pas le type des données. Si vous souhaitez vérifier également leurs types, utilisez ##[[strictlyContainsValues|#strictlyContainsValues]]##.
}}}

====hasKey

##hasKey## vérifie qu’un tableau contient une certaine clef.

[[[php
$fibonacci = array('1', 2, '3', 5, '8', 13, '21');
$atoum     = array(
    'name'        => 'atoum',
    'owner'       => 'mageekguy',
);

$this
    ->array($fibonacci)
        ->hasKey(0)         // passe
        ->hasKey(1)         // passe
        ->hasKey('1')       // passe
        ->hasKey(10)        // échoue

    ->array($atoum)
        ->hasKey('name')    // passe
        ->hasKey('price')   // échoue
;
]]]

{{{info
##hasKey## ne fait pas de recherche récursive.
}}}

{{{warning
##hasKey## ne teste pas le type des clefs.
}}}

====hasKeys

##hasKeys## vérifie qu’un tableau contient toutes les clefs fournies dans un tableau.

[[[php
$fibonacci = array('1', 2, '3', 5, '8', 13, '21');
$atoum     = array(
    'name'        => 'atoum',
    'owner'       => 'mageekguy',
);

$this
    ->array($fibonacci)
        ->hasKeys(array(0, 2, 4))           // passe
        ->hasKeys(array('0', 2))            // passe
        ->hasKeys(array('4', 0, 3))         // passe
        ->hasKeys(array(0, 3, 10))          // échoue

    ->array($atoum)
        ->hasKeys(array('name', 'owner'))   // passe
        ->hasKeys(array('name', 'price'))   // échoue
;
]]]

{{{info
##hasKeys## ne fait pas de recherche récursive.
}}}

{{{warning
##hasKeys## ne teste pas le type des clefs.
}}}

====hasSize====arrayHasSize

##hasSize## vérifie la taille d’un tableau.

[[[php
$fibonacci = array('1', 2, '3', 5, '8', 13, '21');

$this
    ->array($fibonacci)
        ->hasSize(7)        // passe
        ->hasSize(10)       // échoue
;
]]]

{{{info
##hasSize## n’est pas récursif.
}}}

====isEmpty====arrayIsEmpty

##isEmpty## vérifie qu’un tableau est vide.

[[[php
$emptyArray    = array();
$nonEmptyArray = array(null, null);

$this
    ->array($emptyArray)
        ->isEmpty()         // passe

    ->array($nonEmptyArray)
        ->isEmpty()         // échoue
;
]]]

====isEqualTo====arrayIsEqualTo

{{{inheritance
##isEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isEqualTo##|#variableIsEqualTo]]
}}}

====isIdenticalTo====arrayIsIdenticalTo

{{{inheritance
##isIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isIdenticalTo##|#variableIsIdenticalTo]]
}}}

====isNotEmpty====arrayIsNotEmpty

##isNotEmpty## vérifie qu’un tableau n’est pas vide.

[[[php
$emptyArray    = array();
$nonEmptyArray = array(null, null);

$this
    ->array($emptyArray)
        ->isNotEmpty()      // échoue

    ->array($nonEmptyArray)
        ->isNotEmpty()      // passe
;
]]]

====isNotEqualTo====arrayIsNotEqualTo

{{{inheritance
##isNotEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotEqualTo##|#variableIsNotEqualTo]]
}}}

====isNotIdenticalTo====arrayIsNotIdenticalTo

{{{inheritance
##isNotIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotIdenticalTo##|#variableIsNotIdenticalTo]]
}}}

====keys

##keys## vous permet de récupérer un asserter de type ##[[array|#array]]## contenant les clefs du tableau testé.

[[[php
$atoum = array(
    'name'  => 'atoum',
    'owner' => 'mageekguy',
);

$this
    ->array($atoum)
        ->keys
            ->isEqualTo(
                array(
                    'name',
                    'owner',
                )
            )
;
]]]

====notContains====arrayNotContains

##notContains## vérifie qu’un tableau ne contient pas une donnée.

[[[php
$fibonacci = array('1', 2, '3', 5, '8', 13, '21');

$this
    ->array($fibonacci)
        ->notContains(null)         // passe
        ->notContains(1)            // échoue
        ->notContains(10)           // passe
;
]]]

{{{info
##notContains## ne fait pas de recherche récursive.
}}}

{{{warning
##notContains## ne teste pas le type de la donnée. Si vous souhaitez vérifier également son type, utilisez ##[[strictlyNotContains|#strictlyNotContains]]##.
}}}

====notContainsValues

##notContainsValues## vérifie qu’un tableau ne contient aucune des données fournies dans un tableau.

[[[php
$fibonacci = array('1', 2, '3', 5, '8', 13, '21');

$this
    ->array($array)
        ->notContainsValues(array(1, 4, 10))    // échoue
        ->notContainsValues(array(4, 10, 34))   // passe
        ->notContainsValues(array(1, '2', 3))   // échoue
;
]]]

{{{info
##notContainsValues## ne fait pas de recherche récursive.
}}}

{{{warning
##notContainsValues## ne teste pas le type des données. Si vous souhaitez vérifier également leurs types, utilisez ##[[strictlyNotContainsValues|#strictlyNotContainsValues]]##.
}}}

====notHasKey

##notHasKey## vérifie qu’un tableau ne contient pas une certaine clef.

[[[php
$fibonacci = array('1', 2, '3', 5, '8', 13, '21');
$atoum     = array(
    'name'  => 'atoum',
    'owner' => 'mageekguy',
);

$this
    ->array($fibonacci)
        ->notHasKey(0)          // échoue
        ->notHasKey(1)          // échoue
        ->notHasKey('1')        // échoue
        ->notHasKey(10)         // passe

    ->array($atoum)
        ->notHasKey('name')     // échoue
        ->notHasKey('price')    // passe
;
]]]

{{{info
##notHasKey## ne fait pas de recherche récursive.
}}}

{{{warning
##notHasKey## ne teste pas le type des clefs.
}}}

====notHasKeys

##notHasKeys## vérifie qu’un tableau ne contient aucune des clefs fournies dans un tableau.

[[[php
$fibonacci = array('1', 2, '3', 5, '8', 13, '21');
$atoum     = array(
    'name'        => 'atoum',
    'owner'       => 'mageekguy',
);

$this
    ->array($fibonacci)
        ->notHasKeys(array(0, 2, 4))            // échoue
        ->notHasKeys(array('0', 2))             // échoue
        ->notHasKeys(array('4', 0, 3))          // échoue
        ->notHasKeys(array(10, 11, 12))         // passe

    ->array($atoum)
        ->notHasKeys(array('name', 'owner'))    // échoue
        ->notHasKeys(array('foo', 'price'))     // passe
;
]]]

{{{info
##notHasKeys## ne fait pas de recherche récursive.
}}}

{{{warning
##notHasKeys## ne teste pas le type des clefs.
}}}

====size

##size## vous permet de récupérer un asserter de type ##[[integer|#integer]]## contenant la taille du tableau testé.

[[[php
$fibonacci = array('1', 2, '3', 5, '8', 13, '21');

$this
    ->array($fibonacci)
        ->size
            ->isGreaterThan(5)
;
]]]

====strictlyContains

##strictlyContains## vérifie qu’un tableau contient une certaine donnée (même valeur et même type).

[[[php
$fibonacci = array('1', 2, '3', 5, '8', 13, '21');

$this
    ->array($fibonacci)
        ->strictlyContains('1')     // passe
        ->strictlyContains(1)       // échoue
        ->strictlyContains('2')     // échoue
        ->strictlyContains(2)       // passe
        ->strictlyContains(10)      // échoue
;
]]]

{{{info
##strictlyContains## ne fait pas de recherche récursive.
}}}

{{{warning
##strictlyContains## teste le type de la donnée. Si vous ne souhaitez pas vérifier son type, utilisez ##[[contains|#arrayContains]]##.
}}}

====strictlyContainsValues

##strictlyContainsValues## vérifie qu’un tableau contient toutes les données fournies dans un tableau (même valeur et même type).

[[[php
$fibonacci = array('1', 2, '3', 5, '8', 13, '21');

$this
    ->array($array)
        ->strictlyContainsValues(array('1', 2, '3'))    // passe
        ->strictlyContainsValues(array(1, 2, 3))        // échoue
        ->strictlyContainsValues(array(5, '8', 13))     // passe
        ->strictlyContainsValues(array('5', '8', '13')) // échoue
        ->strictlyContainsValues(array(0, '1', 2))      // échoue
;
]]]

{{{info
##strictlyContainsValues## ne fait pas de recherche récursive.
}}}

{{{warning
##strictlyContainsValues## teste le type des données. Si vous ne souhaitez pas vérifier leurs types, utilisez ##[[containsValues|#containsValues]]##.
}}}

====strictlyNotContains

##strictlyNotContains## vérifie qu’un tableau ne contient pas une donnée (même valeur et même type).

[[[php
$fibonacci = array('1', 2, '3', 5, '8', 13, '21');

$this
    ->array($fibonacci)
        ->strictlyNotContains(null)         // passe
        ->strictlyNotContains('1')          // échoue
        ->strictlyNotContains(1)            // passe
        ->strictlyNotContains(10)           // passe
;
]]]

{{{info
##strictlyNotContains## ne fait pas de recherche récursive.
}}}

{{{warning
##strictlyNotContains## teste le type de la donnée. Si vous ne souhaitez pas vérifier son type, utilisez ##[[notContains|#arrayNotContains]]##.
}}}

====strictlyNotContainsValues

##strictlyNotContainsValues## vérifie qu’un tableau ne contient aucune des données fournies dans un tableau (même valeur et même type).

[[[php
$fibonacci = array('1', 2, '3', 5, '8', 13, '21');

$this
    ->array($array)
        ->strictlyNotContainsValues(array('1', 4, 10))  // échoue
        ->strictlyNotContainsValues(array(1, 4, 10))    // passe
        ->strictlyNotContainsValues(array(4, 10, 34))   // passe
        ->strictlyNotContainsValues(array('1', 2, '3')) // échoue
        ->strictlyNotContainsValues(array(1, '2', 3))   // passe
;
]]]

{{{info
##strictlyNotContainsValues## ne fait pas de recherche récursive.
}}}

{{{warning
##strictlyNotContainsValues## teste le type des données. Si vous ne souhaitez pas vérifier leurs types, utilisez ##[[notContainsValues|#notContainsValues]]##.
}}}



===string

C’est l’assertion dédiée aux chaînes de caractères.

====contains====stringContains

##contains## vérifie qu’une chaîne de caractère contient une autre chaîne de caractère donnée.

[[[php
$string = 'Hello world';

$this
    ->string($string)
        ->contains('ll')    // passe
        ->contains(' ')     // passe
        ->contains('php')   // échoue
;
]]]

====hasLength====stringHasLength

##hasLength## vérifie la taille d’une chaîne de caractères.

[[[php
$string = 'Hello world';

$this
    ->string($string)
        ->hasLength(11)     // passe
        ->hasLength(20)     // échoue
;
]]]

====hasLengthGreaterThan====stringHasLengthGreaterThan

##hasLengthGreaterThan## vérifie que la taille d’une chaîne de caractères est plus grande qu’une valeur donnée.

[[[php
$string = 'Hello world';

$this
    ->string($string)
        ->hasLengthGreaterThan(10)     // passe
        ->hasLengthGreaterThan(20)     // échoue
;
]]]

====hasLengthLessThan====stringHasLengthLessThan

##hasLengthLessThan## vérifie que la taille d’une chaîne de caractères est plus petite qu’une valeur donnée.

[[[php
$string = 'Hello world';

$this
    ->string($string)
        ->hasLengthLessThan(20)     // passe
        ->hasLengthLessThan(10)     // échoue
;
]]]

====isEmpty====stringIsEmpty

##isEmpty## vérifie qu’une chaîne de caractères est vide.

[[[php
$emptyString    = '';
$nonEmptyString = 'atoum';

$this
    ->string($emptyString)
        ->isEmpty()             // passe

    ->string($nonEmptyString)
        ->isEmpty()             // échoue
;
]]]

====isEqualTo====stringIsEqualTo

{{{inheritance
##isEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isEqualTo##|#variableIsEqualTo]]
}}}

====isEqualToContentsOfFile====stringIsEqualToContentsOfFile

##isEqualToContentsOfFile## vérifie qu’une chaîne de caractère est égale au contenu d’un fichier donné par son chemin.

[[[php
$this
    ->string($string)
        ->isEqualToContentsOfFile('/path/to/file')
;
]]]

{{{info
si le fichier n’existe pas, le test échoue.
}}}

====isIdenticalTo====stringIsIdenticalTo

{{{inheritance
##isIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isIdenticalTo##|#variableIsIdenticalTo]]
}}}

====isNotEmpty====stringIsNotEmpty

##isNotEmpty## vérifie qu’une chaîne de caractères n’est pas vide.

[[[php
$emptyString    = '';
$nonEmptyString = 'atoum';

$this
    ->string($emptyString)
        ->isNotEmpty()          // échoue

    ->string($nonEmptyString)
        ->isNotEmpty()          // passe
;
]]]

====isNotEqualTo====stringIsNotEqualTo

{{{inheritance
##isNotEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotEqualTo##|#variableIsNotEqualTo]]
}}}

====isNotIdenticalTo====stringIsNotIdenticalTo

{{{inheritance
##isNotIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotIdenticalTo##|#variableIsNotIdenticalTo]]
}}}

====length

##length## vous permet de récupérer un asserter de type ##[[integer|#integer]]## contenant la taille de la chaîne de caractères testée.

[[[php
$string = 'atoum'

$this
    ->string($string)
        ->length
            ->isGreaterThanOrEqualTo(5)
;
]]]

====match====stringMatch

##match## vérifie qu’une expression régulière correspond à la chaîne de caractères.

[[[php
$phone = '0102030405';
$vdm   = "Aujourd'hui, à 57 ans, mon père s'est fait tatouer une licorne sur l'épaule. VDM";

$this
    ->string($phone)
        ->match('#^0[1-9]\d{8}$#')

    ->string($vdm)
        ->match("#^Aujourd'hui.*VDM$#")
;
]]]

====notContains====stringNotContains

##notContains## vérifie qu’une chaîne de caractère ne contient pas une autre chaîne de caractère donnée.

[[[php
$string = 'Hello world';

$this
    ->string($string)
        ->notContains('php')   // passe
        ->notContains(';')     // passe
        ->notContains('ll')    // échoue
        ->notContains(' ')     // échoue
;
]]]



===castToString

C’est l’assertion dédiée aux tests sur le transtypage d’objets en chaîne de caractères.

[[[php
class AtoumVersion {
    private $version = '1.0';

    public function __toString() {
        return 'atoum v' . $this->version;
    }
}

$this
    ->castToString(new AtoumVersion())
        ->isEqualTo('atoum v1.0')
;
]]]

====contains====castToStringContains

{{{inheritance
##contains## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::contains##|#stringContains]]
}}}

====notContains====castToStringNotContains

{{{inheritance
##notContains## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::notContains##|#stringNotContains]]
}}}

====hasLength====castToStringHasLength

{{{inheritance
##hasLength## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::hasLength##|#stringHasLength]]
}}}

====hasLengthGreaterThan====castToStringHasLengthGreaterThan

{{{inheritance
##hasLengthGreaterThan## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::hasLengthGreaterThan##|#stringHasLengthGreaterThan]]
}}}

====hasLengthLessThan====castToStringHasLengthLessThan

{{{inheritance
##hasLengthLessThan## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::hasLengthLessThan##|#stringHasLengthLessThan]]
}}}

====isEmpty====castToStringIsEmpty

{{{inheritance
##isEmpty## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::isEmpty##|#stringIsEmpty]]
}}}

====isEqualTo====castToStringIsEqualTo

{{{inheritance
##isEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isEqualTo##|#variableIsEqualTo]]
}}}

====isEqualToContentsOfFile====castToStringIsEqualToContentsOfFile

{{{inheritance
##isEqualToContentsOfFile## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::isEqualToContentsOfFile##|#stringIsEqualToContentsOfFile]]
}}}

====isIdenticalTo====castToStringIsIdenticalTo

{{{inheritance
##isIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isIdenticalTo##|#variableIsIdenticalTo]]
}}}

====isNotEmpty====castToStringIsNotEmpty

{{{inheritance
##isNotEmpty## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::isNotEmpty##|#stringIsNotEmpty]]
}}}

====isNotEqualTo====castToStringIsNotEqualTo

{{{inheritance
##isNotEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotEqualTo##|#variableIsNotEqualTo]]
}}}

====isNotIdenticalTo====castToStringIsNotIdenticalTo

{{{inheritance
##isNotIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotIdenticalTo##|#variableIsNotIdenticalTo]]
}}}

====match====castToStringMatch

{{{inheritance
##match## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::match##|#stringMatch]]
}}}



===hash

C’est l’assertion dédiée aux tests sur les hashs (empreintes numériques).

====contains====hashContains

{{{inheritance
##contains## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::contains##|#stringContains]]
}}}

====isEqualTo====hashIsEqualTo

{{{inheritance
##isEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isEqualTo##|#variableIsEqualTo]]
}}}

====isEqualToContentsOfFile====hashIsEqualToContentsOfFile

{{{inheritance
##isEqualToContentsOfFile## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::isEqualToContentsOfFile##|#stringIsEqualToContentsOfFile]]
}}}

====isIdenticalTo====hashIsIdenticalTo

{{{inheritance
##isIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isIdenticalTo##|#variableIsIdenticalTo]]
}}}

====isMd5

##isMd5## vérifie que la chaîne de caractère est au format ##md5##, c’est-à-dire une chaîne hexadécimale de 32 caractères.

[[[php
$hash    = hash('md5', 'atoum');
$notHash = 'atoum';

$this
    ->hash($hash)
        ->isMd5()       // passe
    ->hash($notHash)
        ->isMd5()       // échoue
;
]]]

====isNotEqualTo====hashIsNotEqualTo

{{{inheritance
##isNotEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotEqualTo##|#variableIsNotEqualTo]]
}}}

====isNotIdenticalTo====hashIsNotIdenticalTo

{{{inheritance
##isNotIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotIdenticalTo##|#variableIsNotIdenticalTo]]
}}}

====isSha1

##isSha1## vérifie que la chaîne de caractère est au format ##sha1##, c’est-à-dire une chaîne hexadécimale de 40 caractères.

[[[php
$hash    = hash('sha1', 'atoum');
$notHash = 'atoum';

$this
    ->hash($hash)
        ->isSha1()      // passe
    ->hash($notHash)
        ->isSha1()      // échoue
;
]]]

====isSha256

##isSha256## vérifie que la chaîne de caractère est au format ##sha256##, c’est-à-dire une chaîne hexadécimale de 64 caractères.

[[[php
$hash    = hash('sha256', 'atoum');
$notHash = 'atoum';

$this
    ->hash($hash)
        ->isSha256()    // passe
    ->hash($notHash)
        ->isSha256()    // échoue
;
]]]

====isSha512

##isSha512## vérifie que la chaîne de caractère est au format ##sha512##, c’est-à-dire une chaîne hexadécimale de 128 caractères.

[[[php
$hash    = hash('sha512', 'atoum');
$notHash = 'atoum';

$this
    ->hash($hash)
        ->isSha512()    // passe
    ->hash($notHash)
        ->isSha512()    // échoue
;
]]]

====notContains====hashNotContains

{{{inheritance
##notContains## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::notContains##|#stringNotContains]]
}}}



===output

C’est l’assertion dédiée aux tests sur les sorties, c’est-à-dire tout ce qui est censé être affiché à l’écran.

[[[php
$this
    ->output(
        function() {
            echo 'Hello world';
        }
    )
;
]]]

{{{info
La syntaxe utilise les fonctions anonymes (aussi appelées fermetures ou closures) introduites en PHP 5.3. Reportez-vous au [[manuel de PHP|http://php.net/functions.anonymous]] pour avoir plus d’informations sur le sujet.
}}}

====contains====outputContains

{{{inheritance
##contains## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::contains##|#stringContains]]
}}}

====hasLength====outputHasLength

{{{inheritance
##hasLength## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::hasLength##|#stringHasLength]]
}}}

====hasLengthGreaterThan====outputHasLengthGreaterThan

{{{inheritance
##hasLengthGreaterThan## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::hasLengthGreaterThan##|#stringHasLengthGreaterThan]]
}}}

====hasLengthLessThan====outputHasLengthLessThan

{{{inheritance
##hasLengthLessThan## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::hasLengthLessThan##|#stringHasLengthLessThan]]
}}}

====isEmpty====outputIsEmpty

{{{inheritance
##isEmpty## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::isEmpty##|#stringIsEmpty]]
}}}

====isEqualTo====outputIsEqualTo

{{{inheritance
##isEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isEqualTo##|#variableIsEqualTo]]
}}}

====isEqualToContentsOfFile====outputIsEqualToContentsOfFile

{{{inheritance
##isEqualToContentsOfFile## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::isEqualToContentsOfFile##|#stringIsEqualToContentsOfFile]]
}}}

====isIdenticalTo====outputIsIdenticalTo

{{{inheritance
##isIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isIdenticalTo##|#variableIsIdenticalTo]]
}}}

====isNotEmpty====outputIsNotEmpty

{{{inheritance
##isNotEmpty## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::isNotEmpty##|#stringIsNotEmpty]]
}}}

====isNotEqualTo====outputIsNotEqualTo

{{{inheritance
##isNotEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotEqualTo##|#variableIsNotEqualTo]]
}}}

====isNotIdenticalTo====outputIsNotIdenticalTo

{{{inheritance
##isNotIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotIdenticalTo##|#variableIsNotIdenticalTo]]
}}}

====match====outputMatch

{{{inheritance
##match## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::match##|#stringMatch]]
}}}

====notContains====outputNotContains

{{{inheritance
##notContains## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::notContains##|#stringNotContains]]
}}}



===utf8String

C’est l’assertion dédiée aux chaînes de caractères UTF-8.

{{{info
##utf8Strings## utilise les fonctions ##mb_*## pour gérer les chaînes multi-octets. Reportez-vous au manuel de PHP pour avoir plus d’information sur l’extension ##[[mbstring|http://php.net/mbstring]]##.
}}}

====contains====utf8StringContains

{{{inheritance
##contains## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::contains##|#stringContains]]
}}}

====hasLength====utf8StringHasLength

{{{inheritance
##hasLength## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::hasLength##|#stringHasLength]]
}}}

====hasLengthGreaterThan====utf8StringHasLengthGreaterThan

{{{inheritance
##hasLengthGreaterThan## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::hasLengthGreaterThan##|#stringHasLengthGreaterThan]]
}}}

====hasLengthLessThan====utf8StringHasLengthLessThan

{{{inheritance
##hasLengthLessThan## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::hasLengthLessThan##|#stringHasLengthLessThan]]
}}}

====isEmpty====utf8StringIsEmpty

{{{inheritance
##isEmpty## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::isEmpty##|#stringIsEmpty]]
}}}

====isEqualTo====utf8StringIsEqualTo

{{{inheritance
##isEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isEqualTo##|#variableIsEqualTo]]
}}}

====isEqualToContentsOfFile====utf8StringIsEqualToContentsOfFile

{{{inheritance
##isEqualToContentsOfFile## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::isEqualToContentsOfFile##|#stringIsEqualToContentsOfFile]]
}}}

====isIdenticalTo====utf8StringIsIdenticalTo

{{{inheritance
##isIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isIdenticalTo##|#variableIsIdenticalTo]]
}}}

====isNotEmpty====utf8StringIsNotEmpty

{{{inheritance
##isNotEmpty## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::isNotEmpty##|#stringIsNotEmpty]]
}}}

====isNotEqualTo====utf8StringIsNotEqualTo

{{{inheritance
##isNotEqualTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotEqualTo##|#variableIsNotEqualTo]]
}}}

====isNotIdenticalTo====utf8StringIsNotIdenticalTo

{{{inheritance
##isNotIdenticalTo## est une méthode héritée de l’asserter ##variable##.
Pour plus d’informations, reportez-vous à la documentation de [[##variable::isNotIdenticalTo##|#variableIsNotIdenticalTo]]
}}}

====match====utf8StringMatch

{{{inheritance
##match## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::match##|#stringMatch]]
}}}

{{{info
Pensez à bien ajouter ##u## comme option de recherche dans votre expression régulière. Reportez-vous au [[manuel de PHP|http://php.net/reference.pcre.pattern.modifiers]] pour avoir plus d’informations sur le sujet.
}}}

[[[php
$vdm = "Aujourd'hui, à 57 ans, mon père s'est fait tatouer une licorne sur l'épaule. VDM";

$this
    ->utf8String($vdm)
        ->match("#^Aujourd'hui.*VDM$#u")
;
]]]

====notContains====utf8StringNotContains

{{{inheritance
##notContains## est une méthode héritée de l’asserter ##string##.
Pour plus d’informations, reportez-vous à la documentation de [[##string::notContains##|#stringNotContains]]
}}}



===afterDestructionOf

C’est l’assertion dédiée à la destruction des objets.

Cette assertion ne fait que prendre un objet, vérifier que la méthode ##\__destruct()## est bien définie puis l’appelle.

Si ##\__destruct()## existe bien et si son appel se passe sans erreur ni exception, alors le test passe.

[[[php
$this
    ->afterDestructionOf($objectWithDestructor)     // passe
    ->afterDestructionOf($objectWithoutDestructor)  // échoue
;
]]]



===error

C’est l’assertion dédiée aux erreurs.

[[[php
$this
    ->when(
        function() {
            trigger_error('message');
        }
    )
        ->error()
            ->exists() // ou notExists
;
]]]

{{{info
La syntaxe utilise les fonctions anonymes (aussi appelées fermetures ou closures) introduites en PHP 5.3. Reportez-vous au [[manuel de PHP|http://php.net/functions.anonymous]] pour avoir plus d’informations sur le sujet.
}}}

{{{warning
Les types d’erreur E_ERROR, E_PARSE, E_CORE_ERROR, E_CORE_WARNING, E_COMPILE_ERROR, E_COMPILE_WARNING ainsi que la plupart des E_STRICT ne peuvent pas être gérés avec cette fonction.
}}}

====exists

##exists## vérifie qu’une erreur a été levée lors de l’exécution du code précédent.

[[[php
$this
    ->when(
        function() {
            trigger_error('message');
        }
    )
        ->error()
            ->exists()      // passe

    ->when(
        function() {
            // code sans erreur
        }
    )
        ->error()
            ->exists()      // échoue
;
]]]

====notExists

##notExists## vérifie qu’aucune erreur n’a été levée lors de l’exécution du code précédent.

[[[php
$this
    ->when(
        function() {
            trigger_error('message');
        }
    )
        ->error()
            ->notExists()   // échoue

    ->when(
        function() {
            // code sans erreur
        }
    )
        ->error()
            ->notExists()   // passe
;
]]]

====withType

##withType## vérifie le type de l’erreur levée.

[[[php
$this
    ->when(
        function() {
            trigger_error('message');
        }
    )
        ->error()
            ->withType(E_USER_NOTICE)   // passe
            ->withType(E_USER_WARNING)  // échoue
;
]]]



===class

C’est l’assertion dédiée aux classes.

[[[php
$object = new \StdClass;

$this
    ->class(get_class($object))

    ->class('\StdClass')
;
]]]

{{{info
Le mot-clef ##class## étant réservé en PHP, il n’a pas été possible de créer une assertion ##class##. Elle s’appelle donc ##phpClass## et un alias ##class## a été créé. Vous pourrez donc rencontrer des ##->phpClass()## ou des ##->class()##.
}}}

Il est conseillé d’utiliser exclusivement ##->class()##.

====hasInterface

##hasInterface## vérifie que la classe implémente une interface donnée.

[[[php
$this
    ->class('\ArrayIterator')
        ->hasInterface('Countable')     // passe

    ->class('\StdClass')
        ->hasInterface('Countable')     // échoue
;
]]]

====hasMethod

##hasMethod## vérifie que la classe contient une méthode donnée.

[[[php
$this
    ->class('\ArrayIterator')
        ->hasMethod('count')    // passe

    ->class('\StdClass')
        ->hasMethod('count')    // échoue
;
]]]

====hasNoParent

##hasNoParent## vérifie que la classe n’hérite d’aucune classe.

[[[php
$this
    ->class('\StdClass')
        ->hasNoParent()     // passe

    ->class('\FilesystemIterator')
        ->hasNoParent()     // échoue
;
]]]

{{{warning
Une classe peut implémenter une ou plusieurs interfaces et n’hériter d’aucune classe. ##hasNoParent## ne vérifie pas les interfaces, uniquement les classes héritées.
}}}

====hasParent

##hasParent## vérifie que la classe hérite bien d’une classe.

[[[php
$this
    ->class('\StdClass')
        ->hasParent()       // échoue

    ->class('\FilesystemIterator')
        ->hasParent()       // passe
;
]]]

{{{warning
Une classe peut implémenter une ou plusieurs interfaces et n’hériter d’aucune classe. ##hasParent## ne vérifie pas les interfaces, uniquement les classes héritées.
}}}

====isAbstract

##isAbstract## vérifie que la classe est abstraite.

[[[php
$this
    ->class('\StdClass')
        ->isAbstract()       // échoue
;
]]]

====isSubclassOf

##isSubclassOf## vérifie que la classe hérite de la classe donnée.

[[[php
$this
    ->class('\FilesystemIterator')
        ->isSubclassOf('\DirectoryIterator')    // passe
        ->isSubclassOf('\SplFileInfo')          // passe
        ->isSubclassOf('\StdClass')             // échoue
;
]]]


===mock

C’est l’assertion dédiée aux bouchons.

[[[php
$mock = new \mock\MyClass;

$this
    ->mock($mock)
;
]]]

{{{info
Reportez-vous à la documentation sur les [[bouchons|#Les-bouchons-mock]] pour obtenir plus d’informations sur la façon de créer et gérer les bouchons.
}}}

====call

##call## permet de spécifier une méthode du mock à tester

[[[php
$mock = new \mock\MyFirstClass;

$this
    ->object(new MySecondClass($mock))

    ->mock($mock)
        ->call('myMethod')
            ->once()
;
]]]

=====atLeastOnce

##atLeastOnce## vérifie que la méthode testée (voir ##[[call|#call]]##) du mock testé a été appelée au moins une fois.

[[[php
$mock = new \mock\MyFirstClass;

$this
    ->object(new MySecondClass($mock))

    ->mock($mock)
        ->call('myMethod')
            ->atLeastOnce()
;
]]]

=====exactly

##exactly## vérifie que la méthode testée (voir ##[[call|#call]]##) du mock testé exactement un certain nombre de fois.

[[[php
$mock = new \mock\MyFirstClass;

$this
    ->object(new MySecondClass($mock))

    ->mock($mock)
        ->call('myMethod')
            ->exactly(2)
;
]]]

=====never

##never## vérifie que la méthode testée (voir ##[[call|#call]]##) du mock testé n’a jamais été appelée.

[[[php
$mock = new \mock\MyFirstClass;

$this
    ->object(new MySecondClass($mock))

    ->mock($mock)
        ->call('myMethod')
            ->never()
;
]]]

{{{info
##never## est équivalent à ##[[exactly|#exactly]](0)##.
}}}

=====once/twice/thrice

Ces assertions vérifient que la méthode testée (voir ##[[call|#call]]##) du mock testé a été appelée exactement :
* une fois (once)
* deux fois (twice)
* trois fois (thrice)

[[[php
$mock = new \mock\MyFirstClass;

$this
    ->object(new MySecondClass($mock))

    ->mock($mock)
        ->call('myMethod')
            ->once()
        ->call('mySecondMethod')
            ->twice()
        ->call('myThirdMethod')
            ->thrice()
;
]]]

{{{info
##once##, ##twice## et ##thrice## sont respectivement équivalents à un appel à ##[[exactly|#exactly]](1)##, ##[[exactly|#exactly]](2)## et ##[[exactly|#exactly]](3)##.
}}}

=====withAnyArguments

##withAnyArguments## permet de ne pas spécifier les arguments attendus lors de l’appel à la méthode testée (voir ##[[call|#call]]##) du mock testé.

Cette méthode est surtout utile pour remettre à zéro les arguments, comme dans l’exemple suivant :

[[[php
$mock = new \mock\MyFirstClass;

$this
    ->object(new MySecondClass($mock))

    ->mock($mock)
        ->call('myMethod')
            ->withArguments('first')     ->once()
            ->withArguments('second')    ->once()
            ->withAnyArguments()->exactly(2)
;
]]]

=====withArguments

##withArguments## permet de spécifier les paramètres attendus lors de l’appel à la méthode testée (voir ##[[call|#call]]##) du mock testé.

[[[php
$mock = new \mock\MyFirstClass;

$this
    ->object(new MySecondClass($mock))

    ->mock($mock)
        ->call('myMethod')
            ->withArguments('first', 'second')->once()
;
]]]

{{{warning
##withArguments## ne teste pas le type des arguments. Si vous souhaitez vérifier également leurs types, utilisez ##[[withIdenticalArguments|#withIdenticalArguments]]##.
}}}

=====withIdenticalArguments

##withIdenticalArguments## permet de spécifier les paramètres attendus lors de l’appel à la méthode testée (voir ##[[call|#call]]##) du mock testé.

[[[php
$mock = new \mock\MyFirstClass;

$this
    ->object(new MySecondClass($mock))

    ->mock($mock)
        ->call('myMethod')
            ->withIdenticalArguments('first', 'second')->once()
;
]]]

{{{warning
##withIdenticalArguments## teste le type des arguments. Si vous ne souhaitez pas vérifier leurs types, utilisez ##[[withArguments|#withArguments]]##.
}}}

====wasCalled

##wasCalled## vérifie qu’au moins une méthode du mock a été appelée au moins une fois.

[[[php
$mock = new \mock\MyFirstClass;

$this
    ->object(new MySecondClass($mock))

    ->mock($mock)
        ->wasCalled()
;
]]]

====wasNotCalled

##wasNotCalled## vérifie qu’aucune méthode du mock n’a été appelée.

[[[php
$mock = new \mock\MyFirstClass;

$this
    ->object(new MySecondClass($mock))

    ->mock($mock)
        ->wasNotCalled()
;
]]]


===stream

C’est l’assertion dédiée aux stream.

{{{todo
Malheureusement, je n’ai aucune espèce d’idée de son fonctionnement, alors n’hésitez pas à compléter cette partie !
}}}

====isRead

{{{todo
We need help to write this section !
}}}

====isWrite

{{{todo
We need help to write this section !
}}}


==Aide à l’écriture

Il est possible d’écrire des tests unitaires avec atoum de plusieurs manières, et l’une d’elle est d’utiliser des mots-clefs tels que ##if##, ##and## ou bien encore ##then##, ##when## ou ##assert##.

===if, and, then

L’utilisation de ces mots-clefs est très intuitive :

[[[php
$this
    ->if($computer = new computer()))
    ->and($computer->setFirstOperand(2))
    ->and($computer->setSecondOperand(2))
    ->then
        ->object($computer->add())
            ->isIdenticalTo($computer)
        ->integer($computer->getResult())
            ->isEqualTo(4)
;
]]]

Il est important de noter ces mots-clefs n’apporte rien techniquement ou fonctionnellement parlant, car ils n’ont pas d’autre but que de faciliter la compréhension du test et donc sa maintenance en y ajoutant de la sémantique compréhensible facilement par l’Humain et plus particulièrement un développeur.

Ainsi, ##if## et ##and## permettent de définir les conditions préalables pour que les assertions qui suivent le mot-clef ##then## passent avec succès.

Cependant, il n’y a pas de grammaire régissant l’ordre d’utilisation de ces mots-clefs et aucune vérification syntaxique n’est effectuée par atoum.

En conséquence, il est de la responsabilité du développeur de les utiliser de façon à ce que le test soit signifiant, même s’il est par exemple tout à fait possible d’écrire le test de la manière suivante :

[[[php
$this
    ->and($computer = new computer()))
    ->and($computer->setFirstOperand(2))
    ->then
    ->if($computer->setSecondOperand(2))
        ->object($computer->add())
            ->isIdenticalTo($computer)
        ->integer($computer->getResult())
            ->isEqualTo(4)
;
]]]

Pour les mêmes raisons, l’utilisation de ##then## est facultative.

Il est également important de noter qu’il est tout à fait possible d’écrire le même test en n’utilisant aucun mot-clef :

[[[php
$computer = new computer();
$computer->setFirstOperand(2);
$computer->setSecondOperand(2);

$this
    ->object($computer->add())
        ->isIdenticalTo($computer)
    ->integer($computer->getResult())
        ->isEqualTo(4)
;
]]]

Le test ne sera pas plus lent ou plus rapide à exécuter et il n’y a aucun avantage à utiliser une notation ou une autre, l’important étant d’en choisir une et de s’y tenir pour faciliter la maintenance des tests (la problématique est exactement la même que celle des conventions de codage).

===when

En plus de ##if##, ##and## et ##then##, il existe également d’autres mots-clefs.

L’un d’entre eux est ##when##. Il dispose d’une fonctionnalité spécifique introduite pour contourner le fait qu’il est illégal d’écrire en PHP le code suivant :

[[[php
$this
    ->if($object = new object($valueAtKey0 = uniqid()))
    ->and(unset($object[0]))
    ->then
        ->sizeOf($object)
            ->isZero()
;
]]]

Le langage génère en effet dans ce cas l’erreur fatale : ##Parse error: syntax error, unexpected 'unset' (T_UNSET), expecting »)'##

Il est en effet impossible d’utiliser ##unset()## comme argument d’une fonction.

Pour résoudre ce problème, le mot-clef ##when## est capable d’interpréter l’éventuelle fonction anonyme qui lui est passée en argument, ce qui permet d’écrire le test précédent de la manière suivante :

[[[php
$this
    ->if($object = new object($valueAtKey0 = uniqid()))
    ->when(
        function() use ($object) {
            unset($object[0]);
        }
    )
    ->then
      ->sizeOf($object)
        ->isZero()
;
]]]

Bien évidemment, si ##when## ne reçoit pas de fonction anonyme en argument, il se comporte exactement comme if, and et then, à savoir qu’il ne fait absolument rien fonctionnellement parlant.

===assert

Enfin, il existe le mot-clef ##assert## qui a également un fonctionnement un peu particulier.

Pour illustrer son fonctionnement, le test suivant va être utilisé :

[[[php
$this
    ->if($foo = new \mock\foo())
    ->and($bar = new bar($foo))
    ->and($bar->doSomething())
    ->then
        ->mock($foo)
            ->call('doOtherThing')
                ->once()

    ->if($bar->setValue(uniqid())
    ->then
        ->mock($foo)
            ->call('doOtherThing')
                ->exactly(2)
;
]]]

Le test précédent présente un inconvénient en terme de maintenance, car si le développeur a besoin d’intercaler un ou plusieurs nouveaux appels à bar::doOtherThing() entre les deux appels déjà effectués, il sera obligé de mettre à jour en conséquence la valeur de l’argument passé à exactly().

Pour remédier à ce problème, vous pouvez remettre à zéro un mock de 2 manières différentes :
* soit en utilisant $mock->getMockController()->resetCalls() ;
* soit en utilisant $this->resetMock($mock).

[[[php
$this
    ->if($foo = new \mock\foo())
    ->and($bar = new bar($foo))
    ->and($bar->doSomething())
    ->then
        ->mock($foo)
            ->call('doOtherThing')
                ->once()

    // 1ère manière
    ->if($foo->getMockController()->resetCalls())
    ->and($bar->setValue(uniqid())
    ->then
        ->mock($foo)
            ->call('doOtherThing')
                ->once()

    // 2ème manière
    ->if($this->resetMock($foo))
    ->and($bar->setValue(uniqid())
    ->then
        ->mock($foo)
            ->call('doOtherThing')
                ->once()
;
]]]

Ces méthodes effacent la mémoire du contrôleur, il est donc possible d’écrire l’assertion suivante comme si le bouchon n’avait jamais été utilisé.

Le mot-clef ##assert## permet de se passer de l’appel explicite à ##resetCalls()## et de plus il provoque l’effacement de la mémoire de l’ensemble des adaptateurs et des contrôleurs de bouchon définis au moment de son utilisation.

Grâce à lui, il est donc possible d’écrire le test précédent d’une façon plus simple et plus lisible, d’autant qu’il est possible de passer une chaîne de caractère à assert afin d’expliquer le rôle des assertions suivantes :

[[[php
$this
    ->assert('Foo est vide')
        ->if($foo = new \mock\foo())
        ->and($bar = new bar($foo))
        ->and($bar->doSomething())
        ->then
            ->mock($foo)
                ->call('doOtherThing')
                    ->once()

    ->assert('Foo a une valeur')
        ->if($bar->setValue(uniqid())
        ->then
            ->mock($foo)
                ->call('doOtherThing')
                    ->once()
;
]]]

La chaîne de caractères sera de plus reprise dans les messages générés par atoum si l’une des assertions ne passe pas avec succès.


==Le mode loop

Lorsqu’un développeur fait du développement piloté par les tests, il travaille de la manière suivante :

# il commence par créer le test correspondant à ce qu’il veut développer ;
# il exécute le test qu’il vient de créer ;
# il écrit le code permettant au test de passer avec succès ;
# il modifie ou complète son test et repars à l’étape 2.

Concrètement, cela signifie qu’il doit :
* créer son code dans son éditeur favori ;
* quitter son éditeur pour utiliser une console afin d’exécuter son test ;
* revenir à son éditeur pour écrire le code permettant au test de passer avec succès ;
* revenir à la console afin de relancer l’exécution de son test ;
* revenir à son éditeur afin de modifier ou compléter son test ;

Il y a donc bien un cycle qui se répétera tant que la fonctionnalité n’aura pas été développée dans son intégralité.

Cependant, ce cycle est complexe et impose de nombreux allers-retours entre plusieurs logiciels, ainsi que la saisie récurrente d’une même commande dans le terminal afin de lancer l’exécution des tests unitaires.

atoum propose le mode ##loop## disponible via les arguments ##-l## ou ##\--loop##, qui permet au développeur de ne pas avoir à relancer manuellement les tests et permet donc de fluidifier le processus de développement.

Dans ce mode, atoum commence par exécuter une première fois les tests qui lui sont demandés.

Une fois les tests terminés, si les tests ont été passés avec succès par le code, atoum se met simplement en attente :

[[[shell
$ php tests/units/classes/adapter.php -l
> atoum version DEVELOPMENT by Frédéric Hardy (/Users/fch/Atoum)
> PHP path: /usr/local/bin/php
> PHP version:
=> PHP 5.3.8 (cli) (built: Sep 21 2011 23:14:37)
=> Copyright (c) 1997-2011 The PHP Group
=> Zend Engine v2.3.0, Copyright (c) 1998-2011 Zend Technologies
=>     with Xdebug v2.1.1, Copyright (c) 2002-2011, by Derick Rethans
> mageekguy\atoum\tests\units\adapter...
[S___________________________________________________________][1/1]
=> Test duration: 0.02 second.
=> Memory usage: 0.25 Mb.
> Total test duration: 0.02 second.
> Total test memory usage: 0.25 Mb.
> Code coverage value: 100.00%
> Running duration: 0.16 second.
Success (1 test, 0 method, 2 assertions, 0 error, 0 exception) !
Press <Enter> to reexecute, press any other key to stop...
]]]

Si le développeur presse une autre touche que ##Enter##, atoum se terminera.

Dans le cas contraire, atoum réexécutera à nouveau les mêmes tests, sans aucune autre action de la part du développeur.

Dans le cas où le code ne passe pas les tests avec succès, c’est-à-dire si des assertions ne sont pas vérifiées ou s’il y a eu des erreurs ou des exceptions, atoum se met également en attente :

[[[shell
$ php tests/units/classes/adapter.php -l
> atoum version DEVELOPMENT by Frédéric Hardy (/Users/fch/Atoum)
> PHP path: /usr/local/bin/php
> PHP version:
=> PHP 5.3.8 (cli) (built: Sep 21 2011 23:14:37)
=> Copyright (c) 1997-2011 The PHP Group
=> Zend Engine v2.3.0, Copyright (c) 1998-2011 Zend Technologies
=>     with Xdebug v2.1.1, Copyright (c) 2002-2011, by Derick Rethans
> mageekguy\atoum\tests\units\adapter...
[F___________________________________________________________][1/1]
=> Test duration: 0.00 second.
=> Memory usage: 0.00 Mb.
> Total test duration: 0.00 second.
> Total test memory usage: 0.00 Mb.
> Running duration: 0.17 second.
Failure (1 test, 0 method, 1 failure, 0 error, 0 exception) !
> There is 1 failure:
=> mageekguy\atoum\tests\units\adapter::test__call():
In file /Users/fch/Atoum/tests/units/classes/adapter.php on line 17, mageekguy\atoum\asserters\string::isEqualTo() failed: strings are not equals
-Reference
+Data
@@ -1 +1 @@
-string(13) "4ea0354cd717c"
+string(32) "19798c230d5462b3bdae194f364feffa"
Press <Enter> to reexecute, press any other key to stop...
]]]

Tout comme dans le cas ou tout s’est bien passé, si le développeur presse une autre touche que ##Enter##, atoum se terminera.

Cependant, s’il presse la touche ##Enter##, au lieu de rejouer les mêmes tests comme dans le cas où les tests ont été passés avec succès, atoum n’exécutera que les tests en échec, au lieu de les rejouer dans leur intégralité.

Le développeur pourra alors dépiler les problèmes et rejouer les tests en erreur autant de fois que nécessaire simplement en appuyant sur ##Enter##.

De plus, une fois que tous les tests en échec passeront à nouveau avec succès, atoum exécutera automatiquement la totalité de la suite de tests afin de détecter les éventuelles régressions introduites par la ou les corrections effectuées par le développeur.

Bien évidemment, le mode ##loop## ne prend en compte que [[le ou les fichiers de tests unitaires lancés|chapitre3.html#Fichiers-a-executer]] par atoum.


==Le mode debug

Parfois, un test ne passe pas et il est difficile d’en découvrir la raison.

Dans ce cas, l’une des techniques possibles pour remédier au problème est de tracer le comportement du code concerné, soit directement au cœur de la classe testée à l’aide de fonctions du type de ##var_dump()## ou ##print_r()##, soit au niveau du test unitaire.

Et il se trouve que atoum dispose d’un certain nombre d’outils pour faciliter la tâche du développeur dans ce dernier contexte.

Ces outils ne sont cependant actif que lorsque atoum est exécuté à l’aide de l’argument ##\--debug##, afin que l’exécution des tests unitaires ne soit pas perturbée par les instructions relatives au débogage hors de ce contexte.

Lorsque l’argument ##\--debug## est utilisé, trois méthodes peuvent être activée :
* ##dump()## qui permet de connaître le contenu d’une variable ;
* ##stop()## qui permet d’arrêter l’exécution d’un test ;
* ##executeOnFailure()## qui permet de définir une fonction anonyme qui ne sera exécutée qu’en cas d’échec d’une assertion.

Ces trois méthodes s’intègrent parfaitement dans l’interface fluide qui caractérise atoum.

===dump

La méthode ##dump()## peut s’utiliser de la manière suivante :

[[[php
$this
    ->if($foo = new foo())
    ->then
        ->object($foo->setBar($bar = new bar()))
            ->isIdenticalTo($foo)
        ->dump($foo->getBar())
;
]]]

Lors de l’exécution du test, le retour de la méthode ##foo::getBar()## sera affiché sur la sortie standard.

Il est également possible de passer plusieurs arguments à ##dump()##, de la manière suivante :

[[[php
$this
    ->if($foo = new foo())
    ->then
        ->object($foo->setBar($bar = new bar()))
            ->isIdenticalTo($foo)
        ->dump($foo->getBar(), $bar)
;
]]]

===stop

L’utilisation de la méthode ##stop()## est également très simple :

[[[php
$this
    ->if($foo = new foo())
    ->then
        ->object($foo->setBar($bar = new bar()))
            ->isIdenticalTo($foo)
        ->stop() // le test s'arrêtera ici si --debug est utilisé
        ->object($foo->getBar())
            ->isIdenticalTo($bar)
;
]]]

===executeOnFailure

La méthode ##executeOnFailure()## est très puissante et tout aussi simple à utiliser.

Elle prend en effet en argument une fonction anonyme qui sera exécutée si et seulement si l’une des assertions composant le test n’est pas vérifiée. Elle s’utilise de la manière suivante :

[[[php
$this
    ->if($foo = new foo())
    ->executeOnFailure(
        function() use ($foo) {
            var_dump($foo);
        }
    )
    ->then
        ->object($foo->setBar($bar = new bar()))
            ->isIdenticalTo($foo)
        ->object($foo->getBar())
            ->isIdenticalTo($bar)
;
]]]

Dans l’exemple précédent, contrairement à ##dump()## qui provoque systématiquement l’affichage sur la sortie standard le contenu des variables qui lui sont passées en argument, la fonction anonyme passée en argument ne provoquera l’affichage du contenu de la variable ##foo## que si l’une des assertions suivantes est en échec.

Bien évidemment, il est possible de faire appel plusieurs fois à ##executeOnFailure()## dans une même méthode de test pour définir plusieurs fonctions anonymes différentes devant être exécutées en cas d’échec du test.

==Les méthodes d’initialisation

Lorsqu’il exécute les méthodes de test d’une classe, atoum suit le processus suivant :
# il exécute la méthode ##setUp()## de la classe de test ;
# il lance un sous-processus PHP pour exécuter chaque méthode de test ;
# dans le sous-processus PHP, avant d’exécuter la méthode de test, il exécute la méthode ##beforeTestMethod()## de la classe de test ;
# dans le sous-processus PHP, il exécute la méthode de test ;
# dans le sous-processus PHP, il exécute la méthode ##afterTestMethod()## de la classe de test ;
# une fois le sous-processus PHP terminé, il exécute la méthode ##tearDown()## de la classe de test.

Les méthodes ##setUp()## et ##tearDown()## permettent donc respectivement d’initialiser et de nettoyer l’environnement de test pour l’ensemble des méthodes de test de la classe exécutée, à la différence des méthodes ##beforeTestMethod()## et ##afterTestMethod()##.

Ces deux méthodes permettent en effet respectivement d’initialiser et de nettoyer l’environnement d’exécution des tests individuellement pour chacune des méthodes de test de la classe, puisqu’elles sont exécutées dans le même sous-processus, au contraire de ##setUp()## et ##tearDown()##.

C’est d’ailleurs la raison pour laquelle les méthodes ##beforeTestMethod()## et ##afterTestMethod()## acceptent comme argument le nom de la méthode de test exécutée, afin de pouvoir ajuster les traitements en conséquence.

[[[php
<?php
namespace vendor\project\tests\units;

use
    mageekguy\atoum,
    vendor\project
;

require __DIR__ . '/mageekguy.atoum.phar';

class bankAccount extends atoum
{
    public function setUp()
    {
        // Exécutée *avant l'ensemble* des méthodes de test.
        // Initialisation globale.
    }

    public function beforeTestMethod($method)
    {
        // Exécutée *avant chaque* méthode de test.

        switch ($method)
        {
            case 'testGetOwner':
                // Initialisation pour testGetOwner().
            break;

            case 'testGetOperations':
                // Initialisation pour testGetOperations().
            break;
        }
    }

    public function testGetOwner()
    {
        ...
    }

    public function testGetOperations()
    {
        ...
    }

    public function afterTestMethod($method)
    {
        // Exécutée *après chaque* méthode de test.

        switch ($method)
        {
            case 'testGetOwner':
                // Nettoyage pour testGetOwner().
            break;

            case 'testGetOperations':
                // Nettoyage pour testGetOperations().
            break;
        }
    }

    public function tearDown()
    {
        // Exécutée après l'ensemble des méthodes de test.
        // Nettoyage global.
    }
}
]]]

Par défaut, les méthodes ##setUp()##, ##beforeTestMethod()##, ##afterTestMethod()## et ##tearDown()## ne font absolument rien.

Il est donc de la responsabilité du programmeur de les surcharger lorsque c’est nécessaire dans les classes de test concerné.


==Fournisseurs de données (data provider)

Pour vous aider à tester efficacement vos classes, atoum met à votre disposition des fournisseurs de données (data provider en anglais).

Un fournisseur de données est une méthode d’une classe de test chargée de générer des arguments pour une méthode de test, arguments qui seront utilisés par ladite méthode pour valider des assertions.

La définition du fournisseur de données qui doit être utilisé par une méthode de test se fait grâce à l’annotation ##@dataProvider## appliquée à la méthode de test concernée, de la manière suivante :

[[[php
class calculator extends atoum
{
    /**
     * @dataProvider sumDataProvider
     */
    // Veillez à définir le bon nombre d'arguments
    public function testSum($a, $b)
    {
        $this
            ->if($calculator = new project\calculator())
            ->then
                ->integer($calculator->sum($a, $b))->isEqualTo($a + $b)
        ;
    }

    ...
}
]]]

Évidemment, il ne faut pas oublier de définir, au niveau de la méthode de test, les arguments correspondant à ceux qui seront retournés par le fournisseur de données. Si ce n’est pas le cas, atoum générera une erreur lors de l’exécution des tests.

Une fois l’annotation définie, il n’y a plus qu’à créer la méthode correspondante :

[[[php
class calculator extends atoum
{
    ...

    // Fournisseur de données de testSum().
    public function sumDataProvider()
    {
        return array(
            array( 1, 1),
            array( 1, 2),
            array(-1, 1),
            array(-1, 2),
        );
    }
}
]]]

Lors de l’exécution des tests, atoum appellera la méthode de test ##testSum()## successivement avec les arguments ##(1, 1)##, ##(1, 2)##, ##(-1, 1)## et ##(-1, 2)## renvoyés par la méthode ##sumDataProvider()##.

{{{warning
L’isolation des tests ne sera pas utilisée dans ce contexte, ce qui veut dire que chacun des appels successifs à la méthode ##testSum()## sera réalisé dans le même processus PHP.
}}}

{{{info
Un fournisseur de données peut au choix retourner un tableau ou bien un itérateur.
}}}

==Les bouchons (mock)

atoum dispose d’un système de bouchonnage (mock en anglais) puissant et simple à mettre en œuvre qui vous permettra de générer des mocks à partir de classes (existantes ou inexistantes) ou d’interfaces, mais également à partir de classe abstraite. Grâce à ces bouchons, vous pourrez simuler des comportements en redéfinissant les méthodes publiques de vos classes.

===Générer un bouchon

Il y a plusieurs manières de créer un bouchon à partir d’une interface ou d’une classe (abstraite ou non).

La plus simple est de créer un objet dont le nom absolu est préfixé par ##\mock##:

[[[php
// création d'un bouchon de l'interface \Countable
$countableMock = new \mock\Countable;

// création d'un bouchon de la classe abstraite
// \Vendor\Project\AbstractClass
$vendorAppMock = new \mock\Vendor\Project\AbstractClass;

// création d'un bouchon de la classe \StdClass
$stdObject     = new \mock\StdClass;

// création d'un bouchon à partir d'une classe inexistante
$anonymousMock = new \mock\My\Unknown\Class;
]]]

===Le générateur de bouchon

atoum s’appuie sur un composant spécialisé pour générer les bouchons : le ##mockGenerator##. Vous avez accès à ce dernier dans vos tests afin de modifier la procédure de génération des mocks.

Par défaut, les bouchons seront générés dans le namespace ##mock## et se comporteront exactement de la même manière que les instances de la classe originale (le bouchon hérite directement de la classe originale).

====Changer le nom de la classe

Si vous désirez changer le nom de la classe ou son espace de nom, vous devez utiliser le ##mockGenerator##.

Sa méthode ##generate## prend 3 paramètres :
* le nom de l’interface ou de la classe à bouchonner ;
* le nouvel espace de nom, optionnel ;
* le nouveau nom de la classe, optionnel.

[[[php
// création d'un bouchon de l'interface \Countable vers \MyMock\Countable
// on ne change que l'espace de nom
$this->mockGenerator->generate('\Countable', '\MyMock');
$countableMock = new \myMock\Countable;

// création d'un bouchon de la classe abstraite
// \Vendor\Project\AbstractClass vers \MyMock\AClass
// on change l'espace de nom et le nom de la classe
$this->mockGenerator->generate('\Vendor\Project\AbstractClass', '\MyMock', 'AClass');
$vendorAppMock = new \myMock\AClass;

// création d'un bouchon de la classe \StdClass vers \mock\OneClass
// on ne change que le nom de la classe
$this->mockGenerator->generate('\StdClass', null, 'OneClass');
$stdObject     = new \mock\OneClass;
]]]

{{{info
Si vous n’utilisez que le premier argument et ne changez ni l’espace de nommage ni le nom de la classe, alors la première solution est équivalente.
}}}

[[[php
$countableMock = new \mock\Countable;

// est équivalent à:

$this->mockGenerator->generate('\Countable');   // inutile
$countableMock = new \mock\Countable;
]]]

====Shunter les appels aux méthodes parentes

Un bouchon hérite directement de la classe à partir de laquelle il a été généré, ses méthodes se comportent donc exactement de la même manière.

Dans certains cas, il peut être utile de shunter les appels aux méthodes parents afin que leur code ne soit plus exécuté. Le ##mockGenerator## met à votre disposition plusieurs méthodes pour y parvenir :

[[[php
$this->mockGenerator->shuntParentClassCalls();
// le bouchon ne fera pas appel à la classe parente
$countableMock = new \mock\OneClass;
$this->mockGenerator->unshuntParentClassCalls();
]]]

Ici, toutes les méthodes du bouchon se comporteront comme si elles n’avaient pas d’implémentation par contre elles conserveront la signature des méthodes originales. Vous pouvez également préciser les méthodes que vous souhaitez shunter :

[[[php
$this->mockGenerator->shunt('firstMethod');
$this->mockGenerator->shunt('secondMethod');
// le bouchon ne fera pas appel à la classe parente pour les méthodes firstMethod et secondMethod
$countableMock = new \mock\OneClass;
]]]

====Rendre une méthode orpheline

Il peut parfois être intéressant de rendre une méthode orpheline, c’est-à-dire, lui donner une signature et une implémentation vide. Cela peut être particulièrement utile pour générer des bouchons sans avoir à instancier toutes leurs dépendances.

[[[php
class FirstClass {
    protected $dep;

    public function __construct(SecondClass $dep) {
        $this->dep = $dep;
    }
}

class SecondClass {
    protected $deps;

    public function __construct(ThirdClass $a, FourthClass $b) {
        $this->deps = array($a, $b);
    }
}

$this->mockGenerator->orphanize('__construct');
$this->mockGenerator->shuntParentClassCalls();

// Nous pouvons instancier le bouchon sans injecter ses dépendances
$mock = new \mock\SecondClass();

$object = new FirstClass($mock);
]]]

===Modifier le comportement d’un bouchon

Une fois le bouchon créé et instancié, il est souvent utile de pouvoir modifier le comportement de ses méthodes.

Pour cela, il faut passer par son contrôleur en utilisant l’une des méthodes suivantes :

[[[php
$databaseClient = new \mock\Database\Client();

$databaseClient->getMockController()->connect = function() {};
// Équivalent à
$this->calling($databaseClient)->connect = function() {};
]]]

Le ##mockController## vous permet de redéfinir **uniquement les méthodes publiques et abstraites protégées** et met à votre disposition plusieurs méthodes :

[[[php
$databaseClient = new \mock\Database\Client();

// redéfinie la méthode connect : elle retournera toujours true
$this->calling($databaseClient)->connect = true;

// redéfinie la méthode select
$this->calling($databaseClient)->select = function() {
    return array();
};

// redéfinie la méthode query avec des arguments
$result = array();
$this->calling($databaseClient)->query = function(Query $query) use($result) {
    switch($query->type) {
        case Query::SELECT:
            return $result

        default;
            return null;
    }
};

// la méthode connect lèvera une exception
$this->calling($databaseClient)->connect->throw = new \Database\Client\Exception();
]]]

Comme vous pouvez le voir, il est possible d’utiliser plusieurs méthodes afin d’obtenir le comportement souhaité :
* Utiliser une valeur statique qui sera retournée par la méthode
* Utilser une implémentation courte grâce aux fonctions anonymes de PHP
* Utiliser le mot-clef ##throw## pour lever une exception

Vous pouvez également spécifier plusieurs valeurs en fonction de l'ordre d'appel:

[[[php
// défaut
$this->calling($databaseClient)->count = rand(0, 10);
// équivalent à
$this->calling($databaseClient)->count[0] = rand(0, 10);

// 1er appel
$this->calling($databaseClient)->count[1] = 13;

// 3ème appel
$this->calling($databaseClient)->count[3] = 42;
]]]

* Le premier appel retournera 13.
* Le second aura le comportement par défaut, c'est à dire un nombre aléatoire.
* Le troisième appel retournera 42.
* Tous les appels suivants auront le comportement par défaut, c'est à dire des nombres aléatoires.

Si vous souhaitez que plusieurs méthodes du bouchon aient le même comportement, vous pouvez utiliser les méthodes [[##methods##|#methods]] ou [[##methodsWhichMatch##|#methodsWhichMatch]].

====methods

##methods## vous permet, grâce à la fonction anonyme passée en argument, de définir pour quelles méthodes le comportement doit être modifié :

[[[php
// si la méthode a tel ou tel nom,
// on redéfinit son comportement
$this
    ->calling($mock)
        ->methods(
            function($method) {
                return in_array(
                    $method,
                    array(
                        'getOneThing',
                        'getAnOtherThing'
                    )
                );
            }
        )
            ->return = uniqid()
;

// on redéfinit le comportement de toutes les méthodes
$this
    ->calling($mock)
        ->methods()
            ->return = null
;

// si la méthode commence par "get",
// on redéfinit son comportement
$this
    ->calling($mock)
        ->methods(
            function($method) {
                return substr($method, 0, 3) == 'get';
            }
        )
            ->return = uniqid()
;

]]]

Dans le cas du dernier exemple, vous devriez plutôt utiliser [[##methodsWhichMatch##|#methodsWhichMatch]].

{{{info
La syntaxe utilise les fonctions anonymes (aussi appelées fermetures ou closures) introduites en PHP 5.3. Reportez-vous au [[manuel de PHP|http://php.net/functions.anonymous]] pour avoir plus d’informations sur le sujet.
}}}

====methodsWhichMatch

##methodsWhichMatch## vous permet de définir les méthodes où le comportement doit être modifié grâce à l’expression rationnelle passée en argument :

[[[php
// si la méthode commence par "is",
// on redéfinit son comportement
$this
    ->calling($mock)
        ->methodsWhichMatch('/^is/')
            ->return = true
;

// si la méthode commence par "get" (insensible à la casse),
// on redéfinit son comportement
$this
    ->calling($mock)
        ->methodsWhichMatch('/^get/i')
            ->throw = new \exception
;
]]]

{{{info
##methodsWhichMatch## utilise [[##preg_match##|http://php.net/preg_match]] et les expressions rationnelles. Reportez-vous au [[manuel de PHP|http://php.net/pcre]] pour avoir plus d’informations sur le sujet.
}}}

===Cas particulier du constructeur

Pour bouchonner le constructeur d’une classe, il faut :
* créer une instance de la classe \atoum\mock\controller avant d’appeler le constructeur du bouchon ;
* définir via ce contrôleur le comportement du constructeur du bouchon à l’aide d’une fonction anonyme ;
* injecter le contrôleur lors de l’instanciation du bouchon.

[[[php
$controller = new \atoum\mock\controller();
$controller->__construct = function() {};

$databaseClient = new \mock\Database\Client($controller);
]]]

{{{info
Dans l’exemple ci-dessus, le constructeur de la classe ##\Database\Client## n’a aucun argument, nous injectons directement le contrôleur. Dans le cas d’un constructeur ayant des paramètres, il faudra passer le contrôleur en dernier argument, après tous les arguments requis et optionnels.
}}}

===Tester un bouchon

atoum vous permet de vérifier qu’un bouchon a été utilisé correctement.

[[[php
$databaseClient = new \mock\Database\Client();
$databaseClient->getMockController()->connect = function() {};
$databaseClient->getMockController()->query   = array();

$bankAccount = new \Vendor\Project\Bank\Account();
$this
    // utilisation du bouchon via un autre objet
    ->array($bankAccount->getOperation($databaseClient))
        ->isEmpty()

    // test du bouchon
    ->mock($databaseClient)
        ->call('query')
            ->once()        // vérifie que la méthode query
                            // n'a été appelé qu'une seule fois
;
]]]

{{{info
Reportez-vous à la documentation sur l’assertion ##[[mock|#mock]]## pour obtenir plus d’informations sur les tests des bouchons.
}}}
